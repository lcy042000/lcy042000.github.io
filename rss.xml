<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[LEECY's Blog]]></title><description><![CDATA[This is LEECY's Blog]]></description><link>https://lcy042000.github.io</link><image><url>https://lcy042000.github.io/logos/leecy-logo-512W.png</url><title>LEECY&apos;s Blog</title><link>https://lcy042000.github.io</link></image><generator>GatsbyJS Advanced Starter</generator><lastBuildDate>Sat, 09 Dec 2023 13:50:47 GMT</lastBuildDate><atom:link href="https://lcy042000.github.io/rss.xml" rel="self" type="application/rss+xml"/><copyright><![CDATA[© Copyright 2021]]></copyright><item><title><![CDATA[[WHAT]실행 컨텍스트]]></title><description><![CDATA[…]]></description><link>https://lcy042000.github.io/java-script-execution-context</link><guid isPermaLink="false">https://lcy042000.github.io/java-script-execution-context</guid><category><![CDATA[WHAT]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[Execution Context]]></category><pubDate>Fri, 08 Dec 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;실행 컨텍스트는 자바스크립트가 스코프를 기반으로 식별자와 식별자에 바인딩 된 값(식별자 바인딩)을 관리하는 방식과 호이스팅이 발생하는 이유, 클로저의 동작 방식, 이벤트 핸들러와 비동기 처리 방식과 관련되어 있습니다. 따라서, 실행 컨텍스트는 자바스크립트 동작을 담당하는 중요한 개념입니다. 지금부터 자바스크립트의 실행 컨텍스트에 대해서 알아보도록 하겠습니다.&lt;/p&gt;&lt;h2&gt;소스코드의 타입&lt;/h2&gt;&lt;p&gt;ECMAScript는 4가지의 소스코드가 있습니다. 4가지 타입의 소스코드는 실행 컨텍스트를 생성합니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;전역 코드:&lt;/strong&gt; 전역에 존재하는 소스코드.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;함수 코드:&lt;/strong&gt; 함수 내부에 존재하는 소스코드. 함수 내부의 중첩 함수, 클래스 등의 내부 코드는 포함&lt;span role=&quot;img&quot; aria-label=&quot;cross mark&quot;&gt;❌&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;eval 코드:&lt;/strong&gt; 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스코드.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;모듈 코드:&lt;/strong&gt; 모듈 내부에 존재하는 소스코드.&lt;/p&gt;&lt;p&gt;소스코드를 구분하는 이유는 타입에 따라 실행 컨텍스트를 생성하는 과정과 관리 내용이 다르기 때문입니다. &lt;/p&gt;&lt;p&gt;전역 코드는 전역 변수 관리를 위해 최상위 스코프인 전역 스코프를 생성해야 합니다. 전역 코드가 평가되면 전역 실행 컨텍스트가 생성됩니다.&lt;/p&gt;&lt;p&gt;함수 코드는 지역 스코프를 생성하여 지역 변수, 매개 변수, arguments 객체를 관리해야 합니다. 또한, 지역 스코프를 전역 스코프에서 시작된 스코프 체인에 연결해야 합니다. 이를 위해 함수 코드가 평가되면 함수 실행 컨텍스트가 생성됩니다.&lt;/p&gt;&lt;p&gt;eval 코드는 strict mode에서 자신만의 스코프를 생성하며 eval 코드가 평가되면 eval 실행 컨텍스트가 생성됩니다.&lt;/p&gt;&lt;p&gt;모듈 코드는 모듈별로 독립적인 모듈 스코프를 생성하고 모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성됩니다.&lt;/p&gt;&lt;h2&gt;소스코드의 평가와 실행&lt;/h2&gt;&lt;p&gt;자바스크립트 엔진은 소스코드의 평가와 소스코드의 실행 과정으로 나뉘어 처리합니다. 소스코드 평가 과정에서는 실행 컨텍스트를 생성하고 변수, 함수 선언문을 실행하여 생성된 변수와 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프에 등록합니다. 평가 과정 이후 선언문을 제외한 소스코드가 실행되며 ‘런타임’이 시작됩니다. 소스코드의 실행 결과는 실행 컨텍스트가 관리하는 스코프에 등록됩니다.&lt;/p&gt;&lt;h2&gt;실행 컨텍스트의 역할&lt;/h2&gt;&lt;p&gt;코드가 실행되려면 스코프를 구분하여 식별자와 바인딩 된 값의 관리가 필요하며, 중첩 관계에 의해 스코프 체인을 형성하여 식별자를 검색할 수 있어야 합니다. 또한, 전역 객체의 프로퍼티도 검색 가능해야 합니다. 함수 호출 종료 시 호출 이전으로 돌아가기 위해 현재 실행 중인 코드와 이전에 실행된 코드의 분리된 관리도 필요합니다. 이를 모두 관리하는 역할을 담당하는 것이 실행 컨텍스트입니다. 실행 컨텍스트는 소스코드가 실행되는 데 요구되는 환경 제공하고 코드 실행 결과를 관리하는 영역입니다. 식별자와 스코프는 실행 컨텍스트의 &lt;strong&gt;렉시컬 환경&lt;/strong&gt;으로 관리하고 코드 실행 순서는 &lt;strong&gt;실행 컨텍스트 스택&lt;/strong&gt;을 통해 관리합니다.&lt;/p&gt;&lt;h2&gt;실행 컨텍스트 스택&lt;/h2&gt;&lt;p&gt;생성된 실행 컨텍스트는 스택에서 관리되며, 이를 &lt;strong&gt;실행 컨텍스트 스택&lt;/strong&gt;이라고 합니다. 코드 실행 시 실행되는 시간의 흐름에 따라 실행 컨텍스트 스택에 추가되거나 제거됩니다. 실행 컨텍스트 스택은 코드의 실행 순서를 관리하며, 실행 컨텍스트 스택의 최상단에 존재하는 실행 컨텍스트는 현재 실행 중인 코드의 실행 컨텍스트입니다.&lt;/p&gt;&lt;h2&gt;렉시컬 환경&lt;/h2&gt;&lt;p&gt;식별자와 식별자에 바인딩 된 값, 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트를 &lt;strong&gt;렉시컬 환경&lt;/strong&gt;이라 합니다. 렉시컬 환경은 스코프와 식별자를 관리합니다. 렉시컬 환경은 키와 값을 갖는 객체 형태의 스코프를 생성하여 식별자를 키로 등록하며 바인딩된 값을 관리합니다.&lt;/p&gt;&lt;p&gt;렉시컬 환경은 환경 레코드와 외부 헥시컬 환경에 대한 참조로 구성되어 있습니다.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;환경 레코드: 스코프의 식별자 등록과 식별자에 바인딩 된 값을 관리하는 저장소&lt;/li&gt;&lt;li&gt;외부 렉시컬 환경에 대한 참조: 상위 스코프를 가리키며 참조를 통해 단방향 링크드 리스트 형태의 스코프 체인 구현&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;실행 컨텍스트의 생성과 식별자 검색 과정&lt;/h2&gt;&lt;p&gt;추후 작성될 예정입니다.([HOW] 실행 컨텍스트는 어떻게 동작할까?)&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;참고&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;이웅모, ⌈모던 자바스크립트 - Deep Dive⌋, 2020, 23_실행 컨텍스트(p.359 - 387)&lt;/p&gt;</content:encoded><author>8410294@naver.com</author></item><item><title><![CDATA[[WHAT]What is This?]]></title><description><![CDATA[this…]]></description><link>https://lcy042000.github.io/java-script-this</link><guid isPermaLink="false">https://lcy042000.github.io/java-script-this</guid><category><![CDATA[WHAT]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[This]]></category><pubDate>Thu, 07 Dec 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;this 키워드&lt;/h2&gt;&lt;p&gt;객체 내의 메서드는 자신이 속한 객체의 프로퍼티에 접근하여 참조하거나 변경 가능해야 합니다. 자신이 속한 객체의 프로퍼티를 참조하기 위해서는 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 합니다. 이를 위해 자바스크립트는 &lt;strong&gt;this&lt;/strong&gt; 키워드를 제공합니다.&lt;/p&gt;&lt;p&gt;this 키워드는 소속된 객체 또는 생성할 인스턴스를 가리키는 자기 참조 변수로 소속 객체나 생성할 인스턴스의 프로퍼티와 메서드에 접근할 수 있습니다. this는 자바스크립트 엔진에 의해 암묵적으로 생성되며 this가 가리키는 값은 함수 호출 방식에 따라 동적으로 결정됩니다.&lt;/p&gt;&lt;h2&gt;함수 호출 방식과 this 바인딩&lt;/h2&gt;&lt;h3&gt;일반 함수 호출&lt;/h3&gt;&lt;p&gt;일반 함수로 호출하면 함수 내부의 this에 전역 객체가 바인딩 됩니다.&lt;/p&gt;&lt;h3&gt;메서드 호출&lt;/h3&gt;&lt;p&gt;메서드 내부에서 this는 메서드를 호출할 때 메서드 이름 앞의 객체가 바인딩 됩니다. 여기서 주의할 점은 메서드 내부의 this는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩 된다는 점입니다. this에 바인딩 될 객체는 호출 시점에 결정됩니다.&lt;/p&gt;&lt;h3&gt;생성자 함수 호출&lt;/h3&gt;&lt;p&gt;생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스가 바인딩 됩니다. 생성자 함수는 new 키워드를 붙이지 않고 사용할 경우, 일반 함수로 동작하기 때문에 이 경우에는 일반 함수 호출 방식으로 동작합니다.&lt;/p&gt;&lt;h3&gt;Function.prototype.apply/call/bind 메서드에 의한 간접 호출&lt;/h3&gt;&lt;p&gt;Function.prototype.apply()와 Function.prototype.call()은 this로 사용할 객체와 인수 리스트를 인수로 전달받아 함수를 호출합니다. apply 메서드와 call 메서드는 함수를 호출하는 기능을 수행하는 것으로 인수로 전달된 특정 객체를 호출한 함수의 this에 바인딩 합니다.&lt;/p&gt;&lt;p&gt;Function.prototype.bind()는 메서드는 첫 번째 인수로 전달한 값으로 this 바인딩이 교체된 함수를 새롭게 생성해 반환합니다.&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;참고&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;이웅모, ⌈모던 자바스크립트 - Deep Dive⌋, 2020, 22_this(p.342 - 357)&lt;/p&gt;</content:encoded><author>8410294@naver.com</author></item><item><title><![CDATA[[WHAT]JavaScript의 prototype]]></title><description><![CDATA[…]]></description><link>https://lcy042000.github.io/java-script-prototype</link><guid isPermaLink="false">https://lcy042000.github.io/java-script-prototype</guid><category><![CDATA[WHAT]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[Prototype]]></category><pubDate>Wed, 06 Dec 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어입니다. 또한, 자바스크립트는 객체 기반의 프로그래밍 언어로써 자바스크립트를 이루고 있는 거의 모든 것이 객체입니다. 자바스크립트는 &lt;strong&gt;프로토타입&lt;/strong&gt;을 기반으로 상속을 구현합니다.&lt;/p&gt;&lt;p&gt;생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입의 모든 프로퍼티와 메서드를 상속받습니다. 상속은 코드 재사용 측면에서 매우 중요한 요소로 생성자 함수가 생성하는 모든 인스턴스는 공통으로 사용할 프로퍼티와 메서드를 공유할 수 있습니다.&lt;/p&gt;&lt;p&gt;지금부터 자바스크립트의 상속에서 빠질 수 없는 프로토타입에 대해 알아보도록 하겠습니다.&lt;/p&gt;&lt;h2&gt;프로토타입 객체&lt;/h2&gt;&lt;p&gt;프로토타입은 상위 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티를 제공합니다. 하위 객체는 프로토타입의 프로퍼티에 접근 가능하며 이를 자신의 프로퍼티처럼 사용 가능합니다. 객체가 생성되는 방식에 따라 프로토타입이 결정되며 [[Prototype]]에 저장됩니다. 모든 객체는 하나의 프로토타입을 가지며 객체, 프로토타입, 생성자 함수는 서로 연결되어 있습니다.&lt;/p&gt;&lt;p&gt;객체는 [[Prototype]]에 직접 접근할 수 없지만 &lt;strong&gt;&lt;strong&gt; proto &lt;/strong&gt; 접근자 프로퍼티&lt;/strong&gt;를 통해 자신의 프로토타입에 접근 가능합니다.&lt;/p&gt;&lt;p&gt;프로토타입에 접근하기 위해 &lt;strong&gt; proto &lt;/strong&gt; 접근자 프로퍼티를 사용하는 이유는 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해서입니다. 프로토타입 체인은 순환이 되어서는 안되며 단방향 형태로만 이루어져야 합니다.&lt;/p&gt;&lt;p&gt;코드 내에서 &lt;strong&gt; proto &lt;/strong&gt; 접근자 프로퍼티를 사용하는 것은 권장되지 않습니다. 그 이유는 모든 객체가 &lt;strong&gt; proto &lt;/strong&gt; 접근자 프로퍼티를 사용할 수 있는 것이 아니기 때문입니다.&lt;/p&gt;&lt;h3&gt;함수 객체의 prototype 프로퍼티&lt;/h3&gt;&lt;p&gt;함수 객체는 유일하게 prototype 프로퍼티를 가지며 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킵니다. non-constructir인 화살표 함수와 메서드 축약 표현으로 정의한 함수는 prototype 프로퍼티를 갖지 않으며 프로토타입을 생성하지 않습니다. 또한, 일반 함수도 prototype 프로퍼티를 가지고 있지만 객체를 생성하지 않으므로 아무런 의미를 갖지 않습니다.&lt;/p&gt;&lt;p&gt;모든 객체가 가지는 &lt;strong&gt; proto &lt;/strong&gt; 접근자 프로퍼티와 함수 객체의 prototype 프로퍼티는 동일한 프로토타입을 가리킵니다. 하지만 이 두 프로퍼티는 사용하는 주체가 다릅니다.&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;구분&lt;/th&gt;&lt;th&gt;소유&lt;/th&gt;&lt;th&gt;값&lt;/th&gt;&lt;th&gt;사용 주체&lt;/th&gt;&lt;th&gt;사용 목적&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt; proto &lt;/strong&gt; 접근자 프로퍼티&lt;/td&gt;&lt;td&gt;모든 객체&lt;/td&gt;&lt;td&gt;프로토타입의 참조&lt;/td&gt;&lt;td&gt;모든 객체&lt;/td&gt;&lt;td&gt;객체가 자신의 프로토타입에 접근 또는 교체하기 위해 사용&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;prototype 프로퍼티&lt;/td&gt;&lt;td&gt;constructor&lt;/td&gt;&lt;td&gt;프로토타입의 참조&lt;/td&gt;&lt;td&gt;생성자 함수&lt;/td&gt;&lt;td&gt;생성자 함수가 자신이 생성할 객체의 프로토타입을 할당하기 위해 사용&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;프로토타입의 생성 시점&lt;/h2&gt;&lt;p&gt;모든 객체는 생성자 함수와 연결되어 있습니다. 프로토타입은 생성자 함수가 생성되는 시점에 같이 생성됩니다. 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재하기 때문입니다.&lt;/p&gt;&lt;h2&gt;프로토타입 체인&lt;/h2&gt;&lt;p&gt;자바스크립트는 객체의 프로퍼티에 접근할 때 해당 객체에 접근하려는 프로퍼티가 없을 경우 [[Prototype]] 내부 슬롯의 참조를 따라 프로토타입의 프로퍼티에 접근합니다. 이를 프로토타입 체인이라 하며 프로토타입 체인은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 메커니즘입니다.&lt;/p&gt;&lt;p&gt;프로토타입 체인의 종점은 항상 Object.prototype입니다. Object.prototype에서도 프로퍼티를 찾지 못하는 경우에도 에러를 발생하는 것이 아닌 undefined를 반환하므로 이점에 주의해야 합니다.&lt;/p&gt;&lt;h2&gt;오버라이딩과 프로퍼티 섀도잉&lt;/h2&gt;&lt;p&gt;프로토타입이 소유한 프로퍼티를 프로토타입 프로퍼티라고 하며, 인스턴스가 소유한 프로퍼티를 인스턴스 프로퍼티라고 합니다. 프로토타입 프로퍼티와 동일한 이름의 프로퍼티를 인스턴스에 추가하면 인스턴스 프로퍼티에 이를 추가합니다. 이를 &lt;strong&gt;오버라이딩&lt;/strong&gt;이라 하며 상속 관계에 의해 프로퍼티가 가려지는 현상을 &lt;strong&gt;프로퍼티 섀도잉&lt;/strong&gt;이라 합니다.&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;참고&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;이웅모, ⌈모던 자바스크립트 - Deep Dive⌋, 2020, 19_프로토타입(p.260 - 311)&lt;/p&gt;</content:encoded><author>8410294@naver.com</author></item><item><title><![CDATA[[WHAT]var vs let vs const]]></title><description><![CDATA[var 키워드로 선언한 변수의 문제점 var 키워드는 ES5까지 변수를 선언할 수 있는 유일한 방법이었습니다. 하지만 이는 많은 문제점을 내포하고 있습니다. 변수 중복 선언 허용 var 키워드의 변수는 중복 선언이 가능합니다. var…]]></description><link>https://lcy042000.github.io/javascript-variable-keyword</link><guid isPermaLink="false">https://lcy042000.github.io/javascript-variable-keyword</guid><category><![CDATA[WHAT]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[VariableKeyword]]></category><category><![CDATA[let]]></category><category><![CDATA[var]]></category><category><![CDATA[const]]></category><pubDate>Tue, 05 Dec 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;var 키워드로 선언한 변수의 문제점&lt;/h2&gt;&lt;p&gt;var 키워드는 ES5까지 변수를 선언할 수 있는 유일한 방법이었습니다. 하지만 이는 많은 문제점을 내포하고 있습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;변수 중복 선언 허용&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;var 키워드의 변수는 중복 선언이 가능합니다. var 키워드로 선언한 변수를 중복 선언하면 초기화문 유무에 따라 다르게 동작합니다. 초기화문이 있는 변수 선언문은 자바스크립트 엔진에 의해 var 키워드기 없는 것처럼 동작하고 초기화문이 없는 변수 선언문은 무시됩니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;함수 레벨 스코프&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;var 키워드의 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정합니다. 따라서 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 됩니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;변수 호이스팅&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올라진 것처럼 동작합니다. 실제 변수를 선언하기 전이더라도 변수를 참조하면 undefined를 반환합니다. 이는 코드의 가독성을 저하시키고 오류를 발생할 여지를 남니다.&lt;/p&gt;&lt;h2&gt;let 키워드&lt;/h2&gt;&lt;p&gt;ES6에서 새롭게 도입된 변수 선언 키워드인 let에 대해 알아보도록 하겠습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;변수 중복 선언 금지&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;let 키워드의 경우 같은 이름의 변수를 중복 선언하면 문법 에러가 발생합니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;블록 레벨 스코프&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;모든 코드 블록(함수, if 문, for 문, while 문 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따릅니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;변수 호이스팅&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;let 키워드로 선언한 변수는 호이스팅이 발생하지 않는 것처럼 동작합니다. 변수 선언 이전에 변수를 참조할 경우 참조 에러를 발생시킵니다. let 키워드로 선언한 변수는 “선언 단계”와 “초기화 단계”가 분리되어 진행됩니다. 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 &lt;strong&gt;일시적 사각지대&lt;/strong&gt;라고 부릅니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;전역 객체와 let&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;var 키워드로 선언한 전역 변수와 전역 함수, 선언하지 않은 변수에 값을 할당한 암묵적 전역은 전역 객체 window의 프로퍼티가 됩니다. 하지만, let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아닙니다.&lt;/p&gt;&lt;h2&gt;const 키워드&lt;/h2&gt;&lt;p&gt;let 키워드와 대부분 같지만 차이점을 기반으로 알아보도록 하겠습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;선언과 초기화&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;const 키워드의 변수는 선언과 동시에 초기화해야 합니다. 그렇지 않은 경우, 문법 에러가 발생하게 됩니다. 또한 let 키워드와 마찬가지로 블록 레벨 스코프를 가지며 변수 호이스팅이 발생하지 않습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;재할당 금지 및 상수&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;const 키워드의 변수는 재할당이 불가합니다. 또한, const 변수는 상수로 값의 변경이 불가합니다. 한 번 초기화된 상수는 재할당이 금지됩니다. &lt;/p&gt;&lt;p&gt;&lt;strong&gt;const 키워드와 객체&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;const 키워드로 선언된 변수에 원시 값을 선언한 경우에는 값을 변경할 수 없지만 객체를 선언한 경우 값 변경이 가능합니다. const 키워드는 재할당을 금지하는 것이며 값이 변하는 ‘불변’을 의미하지 않기 때문에 객체의 프로퍼티 생성, 삭제, 변경은 가능합니다. 하지만, 변수에 할당된 참조 값의 변경은 불가합니다.&lt;/p&gt;&lt;h2&gt;var vs let vs const&lt;/h2&gt;&lt;p&gt;변수 선언 시에는 const를 우선적으로 사용하고, 값의 변경이 있을 수 있는 경우 let을 사용하는 것이 좋습니다. 변수의 스코프는 최대한 좁게 설정하고 var 키워드의 사용을 지양하는 것이 좋은 코딩 습관입니다.&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;참고&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;이웅모, ⌈모던 자바스크립트 - Deep Dive⌋, 2020, 15_let, const 키워드와 블록 레벨 스코프(p.208 - 218)&lt;/p&gt;</content:encoded><author>8410294@naver.com</author></item><item><title><![CDATA[[HOW]JavaScript의 객체 변경 방지 방법]]></title><description><![CDATA[…]]></description><link>https://lcy042000.github.io/prevent-object-changes</link><guid isPermaLink="false">https://lcy042000.github.io/prevent-object-changes</guid><category><![CDATA[HOW]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[Object]]></category><pubDate>Tue, 05 Dec 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;객체 변경 방지&lt;/h2&gt;&lt;p&gt;객체 변경 가능한 값으로 재할당 없이 프로퍼티의 생성, 변경, 삭제가 가능합니다. 자바스크립트는 객체의 변경을 방지하기 위해 다양한 기능을 제공합니다. 여러 객체 변경 방지 메서드들은 각각 객체의 변경 금지 정도가 다릅니다. 지금부터 각 메서드들에 대해 알아보도록 하겠습니다.&lt;/p&gt;&lt;h2&gt;객체 확장 금지&lt;/h2&gt;&lt;p&gt;객체의 확장을 금지하는 메서드는 Object.preventExtensions()입니다. 객체 확장 금지는 프로퍼티를 추가하는 것을 방지하는 것입니다. 객체의 프로퍼티는 동적 추가와 Object.defineProperty()로 가능하지만 확장이 금지된 경우에는 두 가지 방법 모두 불가능합니다. 객체의 확장 가능 여부는 Object.isExtensible()로 확인 가능합니다.&lt;/p&gt;&lt;h2&gt;객체 밀봉&lt;/h2&gt;&lt;p&gt;객체 밀봉이란 프로퍼티 추가 및 삭제, 프로퍼티 어트리뷰트 재정의 금지를 의미합니다. 밀봉된 객체는 읽기와 쓰기만 가능하며 Object.seal()로 객체를 밀봉할 수 있습니다. 객체가 밀봉됐는지 확인은 Object.isSealed()로 가능합니다.&lt;/p&gt;&lt;h2&gt;객체 동결&lt;/h2&gt;&lt;p&gt;객체 동결은 프로퍼티 추가, 삭제, 프로퍼티 어트리뷰트 재정의 금지, 프로퍼티 값 갱신 금지를 의미하며 동결된 객체는 읽기만 가능합니다. Object.freeze()를 통해 객체를 동결할 수 있습니다. Object.isFrozen()을 통해 객체 동결 여부를 확인할 수 있습니다.&lt;/p&gt;&lt;h2&gt;불변 객체&lt;/h2&gt;&lt;p&gt;객체 확장 금지, 객체 밀봉, 객체 동결은 얕은 변경 방지로 중첩된 객체는 영향을 끼칠 수 없습니다. 중첩된 객체까지 변경이 불가능한 객체를 만들기 위해서는 객체를 값으로 갖는 프로퍼티까지 재귀적으로 객체 변경 방지 메서드를 호출해야 합니다.&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;참고&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;이웅모, ⌈모던 자바스크립트 - Deep Dive⌋, 2020, 16_프로퍼티 어트리뷰트(p.229 - 233)&lt;/p&gt;</content:encoded><author>8410294@naver.com</author></item><item><title><![CDATA[[HOW]전역 변수의 사용을 억제하는 방법]]></title><description><![CDATA[…]]></description><link>https://lcy042000.github.io/not-global-variable-method</link><guid isPermaLink="false">https://lcy042000.github.io/not-global-variable-method</guid><category><![CDATA[HOW]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[Global variable]]></category><pubDate>Thu, 30 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;전역 변수의 무분별한 사용은 위험한 결과를 초래할 수 있습니다. 전역 변수를 반드시 사용해야 하는 경우가 아니라면 사용을 자제해야 하며, 지역 변수를 사용해야 합니다. 지금부터 전역 변수의 사용을 줄일 수 있는 방법에 대해 알아보겠습니다.&lt;/p&gt;&lt;h3&gt;즉시 실행 함수&lt;/h3&gt;&lt;p&gt;함수 정의와 동시에 호출되는 즉시 실행 함수는 단 한 번만 호출되며, 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 됩니다.&lt;/p&gt;&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; foo &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;네임스페이스 객체&lt;/h3&gt;&lt;p&gt;전역 코드에 네임스페이스 객체를 생성하고 전역 변수처럼 사용코자 하는 변수를 프로퍼티로 추가하는 방법입니다. 하지만, 식별자 충돌 방지 효과는 있으나 네임스페이스 객체 자체가 전역 변수에 해당되어 좋은 방법은 아닙니다.&lt;/p&gt;&lt;h3&gt;모듈 패턴&lt;/h3&gt;&lt;p&gt;관련 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만드는 방법입니다. 모듈 패턴은 클로저를 기반으로 동작하여 전역 변수 사용 억제뿐만 아니라 캡슐화까지 구현할 수 있습니다.&lt;/p&gt;&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; Counter &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; num &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;token function&quot;&gt;increase&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;num&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;

		&lt;span class=&quot;token function&quot;&gt;decrease&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;num&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;ES6 모듈&lt;/h3&gt;&lt;p&gt;ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공합니다. 따라서 모듈 내에서 선언된 변수는 전역 변수가 아닙니다. 모던 브라우저에서 모듈을 사용할 수 있습니다.&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;참고&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;이웅모, ⌈모던 자바스크립트 - Deep Dive⌋, 2020, 14_전역 변수의 문제점(p.204 - 207)&lt;/p&gt;</content:encoded><author>8410294@naver.com</author></item><item><title><![CDATA[[WHAT]전역 변수의 문제점]]></title><description><![CDATA[…]]></description><link>https://lcy042000.github.io/global-variable-problem</link><guid isPermaLink="false">https://lcy042000.github.io/global-variable-problem</guid><category><![CDATA[WHAT]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[Global variable Problem]]></category><pubDate>Thu, 30 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;변수의 생명 주기&lt;/h2&gt;&lt;p&gt;변수는 선언에 의해 생성되고 할당을 통해 값을 갖습니다. 변수는 자신이 선언된 위치에서 생성되고 소멸합니다. 지역 변수의 생명 주기는 함수의 생명 주기와 동일합니다. 함수가 호출된 직후 함수 몸체의 코드가 한 줄씩 순차적으로 실행되기 이전에 자바스크립트 엔진에 의해 먼저 실행됩니다. 전역 변수의 경우 함수와 달리 전역 코드는 명시적인 호출과 종료가 없기 때문에 전역 코드와 생명 주기가 동일합니다.&lt;/p&gt;&lt;h2&gt;전역 변수의 문제점&lt;/h2&gt;&lt;h3&gt;1. 암묵적 결합&lt;/h3&gt;&lt;p&gt;전역 변수를 선언한 이유는 코드의 어느 영역에서나 참조하고 할당할 수 있는 변수를 사용하겠다는 뜻입니다. 이는 모든 코드가 전역 변수를 참조하고 변경할 수 있는 &lt;strong&gt;암묵적 결합&lt;/strong&gt;을 허용하는 것입니다. 변수의 유효 범위가 넓어질수록 코드의 가독성을 저하시키고 의도치 않는 변경을 유발할 수 있습니다.&lt;/p&gt;&lt;h3&gt;2. 긴 생명 주기&lt;/h3&gt;&lt;p&gt;전역 변수는 생명 주기가 길기 때문에, 그만큼 메모리 리소스도 사용하게 됩니다. 또한, 전역 변수의 상태를 변경할 수 있는 시간이 길고 기회도 많게 됩니다. 반면에, 지역 변수는 전역 변수보다 생명 주기가 짧고 메모리 리소스 사용도 적기 때문에 오류 발생 확률이 적습니다.&lt;/p&gt;&lt;h3&gt;3. 스코프 체인 상에서 종점 존재&lt;/h3&gt;&lt;p&gt;변수 검색 시 전역 변수가 사장 마지막에 검색되는 스코프 체인 상의 종점에 존재합니다. 따라서, 전역 변수의 검색 속도가 가장 느리기 때문에 성능 저하가 발생할 수 있습니다.&lt;/p&gt;&lt;h3&gt;4. 네임스페이스 오염&lt;/h3&gt;&lt;p&gt;자바스크립트의 문제점 중 하나는 파일이 분리되어 있더라고 하나의 전역 스코프를 공유한다는 것입니다. 만약의 경우, 각각 다른 파일에 동일한 이름의 변수가 존재한다면 예상하지 못한 결과를 가져올 수 있습니다.&lt;/p&gt;&lt;h2&gt;전역 변수 사용 억제법&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://lcy042000.github.io/not-global-variable-method&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://lcy042000.github.io/not-global-variable-method&lt;/a&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;참고&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;이웅모, ⌈모던 자바스크립트 - Deep Dive⌋, 2020, 14_전역 변수의 문제점(p.204 - 207)&lt;/p&gt;</content:encoded><author>8410294@naver.com</author></item><item><title><![CDATA[[WHAT]자바스크립트의 스코프]]></title><description><![CDATA[…]]></description><link>https://lcy042000.github.io/java-script-scope</link><guid isPermaLink="false">https://lcy042000.github.io/java-script-scope</guid><category><![CDATA[WHAT]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[Scope]]></category><pubDate>Wed, 29 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;스코프란?&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;스코프&lt;/strong&gt;는 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)가 자신이 선언된 위치에 따라 다른 코드에서 참조할 수 있는 유효 범위를 의미합니다. 스코프는 식별자의 검색 규칙이며, 이를 통해 자바스크립트 엔진은 어떤 변수를 참조할지 결정합니다.&lt;/p&gt;&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&amp;#x27;global&amp;#x27;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&amp;#x27;local&amp;#x27;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// local&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// global&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위의 예제에서 함수 내부와 외부에서 &amp;#x27;x&amp;#x27;변수를 참조할 때, 자바스크립트 엔진은 어떤 변수를 참조할지 결정해야 합니다. 이러함 참조 결정을 &lt;strong&gt;식별자 결정&lt;/strong&gt;이라고 합니다. 자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조할지 결정하기 때문에 &lt;strong&gt;스코프를 식별자 검색 시 사용하는 규칙&lt;/strong&gt;이라고 할 수 있습니다. &lt;/p&gt;&lt;h2&gt;스코프의 종류&lt;/h2&gt;&lt;p&gt;자신이 선언된 위치에 의해 자신이 유효한 범위인 스코프가 결정됩니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;전역과 전역 스코프:&lt;/strong&gt; 전역이란 코드의 가장 바깥 영역을 말하며, 전역은 전역 스코프(global scope)를 만듭니다. 전역 스코프를 가진 식별자는 코드 어느 곳에서나 참조가 가능합니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;지역과 지역 스코프:&lt;/strong&gt; 지역은 함수 몸체 내부를 말합니다. 지역은 지역 스코프를 만들며, 지역 스코프를 가진 식별자는 자신이 선언된 지역과 하위 지역(중첩 함수)에서만 참조가 가능합니다.&lt;/p&gt;&lt;h2&gt;스코프 체인&lt;/h2&gt;&lt;p&gt;함수는 전역에서 정의될 수 있고, 함수 내부에서도 정의될 수 있습니다. 함수 몸체 내부에서 정의된 함수를 중첩 함수라고 하며, 중첩 함수를 포함하는 함수를 외부 함수라고 합니다.&lt;/p&gt;&lt;p&gt;함수가 중첩될 수 있으므로 함수의 지역 스코프도 중첩될 수 있습니다. 이 경우 스코프가 함수의 중첩에 의해 계층적 구조를 갖습니다. 모든 지역 스코프의 최상위 스코프는 전역 스코프이며 외부 함수의 지역 스코프, 내부 함수의 지역 스코프 순으로 계층이 존재합니다. 이를 &lt;strong&gt;스코프 체인&lt;/strong&gt;이라고 합니다. 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색합니다. 상위 스코프에서 유효한 변수는 하위 스코프에서 참조 가능하지만 하위 스코프의 변수는 상위 스코프에서 참조 불가능합니다.&lt;/p&gt;&lt;h2&gt;함수 레벨 스코프&lt;/h2&gt;&lt;p&gt;대부분의 프로그래밍 언어는 함수 몸체뿐만 아니라 코드 블록(if, for, while 등)도 지역 스코프를 만들지만, 자바스크립트는 함수만이 지역 스코프를 생성합니다. 코드 블록이 만드는 스코프는 &lt;strong&gt;블록 레벨 스코프&lt;/strong&gt;라 합니다. var 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정하며, 이러한 특성을 &lt;strong&gt;함수 레벨 스코프&lt;/strong&gt;라 합니다. 반면, ES6에서 도입된 let, const 키워드는 블록 레벨 스코프를 지원합니다.&lt;/p&gt;&lt;h2&gt;렉시컬 스코프&lt;/h2&gt;&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token function&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위의 코드는 bar 함수의 상위 스코프가 무엇인지에 따라 결정되며 두 가지 패턴을 예측할 수 있습니다.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정한다.&lt;/li&gt;&lt;li&gt;함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;첫 번째 방식은 &lt;strong&gt;동적 스코프&lt;/strong&gt;로 함수가 호출되는 시점에 따라 동적으로 상위 스코프가 결정됩니다. 두 번째 방식을 렉시컬 스코프 또는 정적 스코프라 하며 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정됩니다. 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 &lt;strong&gt;렉시컬 스코프&lt;/strong&gt;를 따릅니다.&lt;/p&gt;&lt;p&gt;따라서, 자바스크립트는 함수를 어디서 정의했는지에 따라 상위 스코프를 결정하며, 함수 호출 위치는 상위 스코프 결정에 영향을 주지 않습니다.&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;참고&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;이웅모, ⌈모던 자바스크립트 - Deep Dive⌋, 2020, 13_스코프(p.189 - 199)&lt;/p&gt;</content:encoded><author>8410294@naver.com</author></item><item><title><![CDATA[[WHAT]JavaScript란 무엇일까?]]></title><description><![CDATA[자바스크립트의 역사 199…]]></description><link>https://lcy042000.github.io/what-java-script</link><guid isPermaLink="false">https://lcy042000.github.io/what-java-script</guid><category><![CDATA[WHAT]]></category><category><![CDATA[JavaScript]]></category><pubDate>Tue, 28 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;aside&gt;💡 모든 브라우저의 표준 프로그래밍 언어이자 현재 웹 애플리케이션 개발에서 빠질 수 없는 존재인 JavaScript에 대해 알아봅시다!&lt;/aside&gt;&lt;img src=&quot;https://redmonk.com/rstephens/files/2023/05/redmonk-language-rankings-jan-2023.jpg&quot; alt=&quot;지난 10년간 프로그래밍 언어 순위&quot;/&gt;&lt;h2&gt;자바스크립트의 역사&lt;/h2&gt;&lt;p&gt;1995년, 웹 페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어 도입을 위해 자바스크립트가 개발되었습니다. 초기에는 각 브라우저 제조사에서 자체적으로 자바스크립트의 기능을 추가함으로써 브라우저에 따라 웹 페이지가 정상적으로 동작하지 않게 되는 &lt;strong&gt;크로스 브라우징 이슈&lt;/strong&gt;가 발생하게 됨을 뜻합니다.&lt;/p&gt;&lt;p&gt;따라서, 자바스크립트의 파편화를 방지하고 모든 브라우저에서 정상적으로 동작할 수 있는 표준화된 자바스크립트의 필요성이 대두되었습니다. 이를 위해, 비영리 표준화 기구인 ECMA 인터네셔널이 표준화를 요청하여 1997년 표준화된 자바스크립트 &lt;strong&gt;ECMAScript&lt;/strong&gt;가 발표되었습니다.&lt;/p&gt;&lt;h2&gt;자바스크립트의 성장&lt;/h2&gt;&lt;p&gt;초창기 자바스크립트는 웹 페이지의 보조적인 역할만을 수행하였습니다. 하지만 점차 기술들이 발전하며 자바스크립트의 활용은 늘어갔습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1. Ajax(Asynchronous JavaScript and XML)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Ajax는 서버와 브라우저가 &lt;strong&gt;비동기 방식&lt;/strong&gt;으로 데이터를 교환할 수 있는 통신 기능입니다. 이전에는 HTML 코드를 전달받아 렌더링하는 방식으로 동작했지만, 필요한 데이터만 전달받아 일부 부분만 렌더링하는 방식이 가능해졌습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2. jQuery&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;jQuery는 조작하기 어려웠던 DOM(Document Object Model)을 쉽게 다룰 수 있게 해주는 라이브러리입니다. 또한, 크로스 브라우징 이슈도 해결할 수 있었습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3. V8 자바스크립트 엔진&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;웹 프로그래밍 언어로서 가능성이 확인된 자바스크립트의 사용이 늘면서 더욱 발전된 자바스크립트 엔진이 요구되었습니다. 이로 인해, 2008년 구글은 V8 자바스크립트 엔진을 선보였고 이는 자바스크립트가 웹 애플리케이션 프로그래밍 언어로 정착하게 될 수 있는 계기가 되었습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4. Node.js&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Node.js는 구글 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경입니다. 브라우저의 자바스크립트 엔진에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서도 동작할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 실행 환경입니다. Node.js는 &lt;strong&gt;비동기 입출력&lt;/strong&gt;을 지원하며 &lt;strong&gt;단일 스레드 이벤트 루프 기반&lt;/strong&gt;으로 동작하여 요청 처리 성능이 우수합니다. Node.js로 인해 프론트엔드 개발에서만 사용하던 자바스크립트를 백엔드 개발에도 활용할 수 있게 되었습니다. 그 결과, 자바스크립트는 크로스 플랫폼을 위한 언어로 주목받게 되었습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;5. SPA 프레임워크&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;현재의 웹 시스템은 뛰어난 성능과 사용자 경험을 제공해야 하는 것이 필수가 되었고, 이는 개발 복잡도를 상승시켰습니다. 이전과 달리 복잡해진 개발 과정을 수행하기 위해 많은 프레임워크들이 등장했고, 그 중 &lt;strong&gt;CBD(Component based development)방법론&lt;/strong&gt;을 기반으로 하는 &lt;strong&gt;SPA(Single Page Application)&lt;/strong&gt;가 대중화되어 React, Vue, Angular 등이 많은 사랑을 받고 있습니다.&lt;/p&gt;&lt;h2&gt;자바스크립트와 ECMAScript&lt;/h2&gt;&lt;p&gt;ECMAScript는 자바스크립트의 표준 사양으로 핵심 문법을 규정합니다. 브라우저 제조사들은 이를 준수하여 브라우저에 내장되는 자바스크립트 엔진을 구현합니다. 기본 골조를 이루는 ECMAScript를 기반으로 브라우저 제조사들이 별도로 Web API를 지원합니다.&lt;/p&gt;&lt;h2&gt;자바스크립트의 특징&lt;/h2&gt;&lt;p&gt;자바스크립트는 웹 브라우저에서 동작하는 유일한 프로그래밍 언어입니다. 다른 언어들과 마찬가지로 기존의 프로그래밍 언어로부터 많은 영향을 받아 기본 문법은 C언어, 자바와 유사하고 Self에서는 프로토타입 기반 상속, Scheme에서는 일급 함수의 개념을 차용했습니다. 자바스크립트는 개발자가 별도 컴파일 작업을 하지 않는 &lt;strong&gt;인터프리터 언어&lt;/strong&gt;로 대부분의 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합하여 처리 속도가 느린 인터프리터의 단점을 해소했습니다. 또한, 자바스크립트는 &lt;strong&gt;명령형&lt;/strong&gt;, &lt;strong&gt;함수형&lt;/strong&gt;, &lt;strong&gt;프로토타입 기반 객체지향 프로그래밍&lt;/strong&gt;을 지원하는 &lt;strong&gt;멀티 패러다임 프로그래밍 언어&lt;/strong&gt;입니다.&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;참고&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;이웅모, ⌈모던 자바스크립트 - Deep Dive⌋, 2020, 02_자바스크립트란?&lt;/p&gt;&lt;p&gt;JS 이미지 / &lt;a href=&quot;https://github.com/voodootikigod/logo.js&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://github.com/voodootikigod/logo.js&lt;/a&gt;&lt;/p&gt;&lt;p&gt;프로그래밍 언어 순위 이미지 / &lt;a href=&quot;https://redmonk.com/rstephens/2023/05/16/top20-jan2023/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://redmonk.com/rstephens/2023/05/16/top20-jan2023/&lt;/a&gt;&lt;/p&gt;</content:encoded><author>8410294@naver.com</author></item><item><title><![CDATA[[WHAT]React란 무엇일까?]]></title><description><![CDATA[들어가기에 앞서… 웹 개발에 관심이 있다면, 'React'라는 단어를 한 번쯤 들어봤을 것입니다. 이 자바스크립트 라이브러리는 웹 개발의 세계에서 큰 중요성을 차지하고 있습니다. 그렇다면 이 React…]]></description><link>https://lcy042000.github.io/what-react</link><guid isPermaLink="false">https://lcy042000.github.io/what-react</guid><category><![CDATA[WHAT]]></category><category><![CDATA[React]]></category><pubDate>Sun, 26 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;들어가기에 앞서…&lt;/h2&gt;&lt;p&gt;웹 개발에 관심이 있다면, &amp;#x27;React&amp;#x27;라는 단어를 한 번쯤 들어봤을 것입니다. 이 자바스크립트 라이브러리는 웹 개발의 세계에서 큰 중요성을 차지하고 있습니다. 그렇다면 이 React는 왜 만들어졌고 어떤 역할을 하는지 알아보도록 하겠습니다.&lt;/p&gt;&lt;h2&gt;React의 탄생 배경&lt;/h2&gt;&lt;p&gt;과거 웹 서비스는 주로 서버에서 HTML을 생성하여 클라이언트에게 제공하는 방식을 사용했습니다. 이는 서비스 제공자가 텍스트 기반의 콘텐츠만 제공하는 단방향 소통 방식이었습니다.&lt;/p&gt;&lt;p&gt;하지만, 디지털 플랫폼의 발전과 함께 사용자의 인터랙션에 따른 동적인 업데이트가 필요해졌고, 이를 위해 AJAX와 같은 기술이 등장하였습니다. 이를 기반으로 한 라이브러리인 jQuery 등이 널리 사용되었습니다.&lt;/p&gt;&lt;p&gt;그러나 사용량의 증가와 이로 인한 데이터의 증가로 웹 애플리케이션의 복잡성이 증가하면서 상태 관리가 점점 어려워졌습니다. 방대한 크기의 서비스를 제공하던 페이스북은 시스템을 유지 보수하기 위해 기존과 다른 방법이 필요했습니다. 이를 해결하기 위해 페이스북의 개발팀은 컴포넌트 기반의 개발 방식을 도입하였고, 이로써 React가 탄생하게 되었습니다.&lt;/p&gt;&lt;h2&gt;React란?&lt;/h2&gt;&lt;p&gt;React는 사용자 인터페이스를 구축하기 위한 JavaScript 라이브러리입니다. React는 싱글 페이지 애플리케이션(SPA)를 구현하며, 서버로부터 하나의 페이지만 받아오지만 라우팅을 통해 여러 화면을 제공합니다. 이는 규모가 큰 시스템에서 데이터 전송 과부화와 같은 성능 문제를 해결 가능하다는 이점을 갖고 있습니다.&lt;/p&gt;&lt;p&gt;React는 웹 페이지의 각 요소를 독립적인 컴포넌트로 취급하여, 이 컴포넌트들을 조합해 전체 애플리케이션을 구성합니다. 이는 각 컴포넌트가 자신의 상태를 관리하고, 다른 컴포넌트와 독립적으로 렌더링될 수 있게 함으로써, 코드의 재사용성을 높이고, 유지보수를 용이하게 합니다.&lt;/p&gt;&lt;p&gt;React의 또 다른 핵심 특징은 Virtual DOM입니다. React는 실제 DOM 대신 Virtual DOM을 사용하여, 변경 사항을 먼저 가상의 DOM에 적용한 후, 실제 DOM에 최소한의 변화만을 반영합니다. 이로 인해 React는 빠른 렌더링 성능을 보장합니다.&lt;/p&gt;&lt;h2&gt;마치며…&lt;/h2&gt;&lt;p&gt;React는 현재 웹 개발에서 주요한 도구로 사용되며, 다양한 기술과 결합하여 다양한 모습을 보여주고 있습니다. 지금까지 Front-end 개발에서 많은 사랑을 받고 있는 React가 어떻게 탄생하였고 무엇인지에 대해 알아보았습니다.&lt;/p&gt;</content:encoded><author>8410294@naver.com</author></item><item><title><![CDATA[[WHY]React를 왜 써야할까?]]></title><description><![CDATA[들어가기에 앞서… React는 프론트엔드 프레임워크에서 가장 인기 있는 프레임워크입니다. HTML, CSS, JS 등 기본적인 웹 기술을 익힌 후, 많은 프론트엔드 개발자들이 React…]]></description><link>https://lcy042000.github.io/why-react</link><guid isPermaLink="false">https://lcy042000.github.io/why-react</guid><category><![CDATA[WHY]]></category><category><![CDATA[React]]></category><pubDate>Fri, 24 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;들어가기에 앞서…&lt;/h2&gt;&lt;p&gt;React는 프론트엔드 프레임워크에서 가장 인기 있는 프레임워크입니다. HTML, CSS, JS 등 기본적인 웹 기술을 익힌 후, 많은 프론트엔드 개발자들이 React를 학습합니다.&lt;/p&gt;&lt;p&gt;저 역시 웹 프론트엔드 개발을 위한 학습 경로로 이러한 순서를 따랐습니다. 그러나 React를 배우기 시작하면서, 왜 이런 프레임워크가 필요한지, 그리고 React의 특별함이 무엇인지에 대한 궁금증이 생겼습니다. 이 글을 통해 그러한 의문을 해결하고, React의 중요성을 이해하는 데 도움이 되고자 합니다.&lt;/p&gt;&lt;h2&gt;React란?&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://lcy042000.github.io/what-react&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://lcy042000.github.io/what-react&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Front-end Framework는 왜 쓰는 걸까?&lt;/h2&gt;&lt;p&gt;프로그래밍에서 프레임워크는 복잡한 문제를 해결하거나 서술하는 데 사용되는 뼈대나 체계를 말합니다. 프레임워크는 개발자가 반복적인 기본 작업을 수행하는 데 들이는 시간을 줄여주며, 안정성이 검증된 코드를 제공하여 개발 과정을 단순화합니다.&lt;/p&gt;&lt;p&gt;프론트엔드 개발에서도 이러한 프레임워크의 필요성은 큽니다. 프론트엔드 프레임워크를 사용하면, UI 구성, 상태 관리, 라우팅 등의 복잡한 문제를 해결하는 데 도움이 됩니다. 또한, 보안에 관련된 복잡한 이슈를 프레임워크가 대신 처리해 주므로, 개발자는 기능 개발에 집중할 수 있습니다.&lt;/p&gt;&lt;h2&gt;React 사용의 이점&lt;/h2&gt;&lt;h3&gt;1. 컴포넌트 기반 구조&lt;/h3&gt;&lt;p&gt;React는 컴포넌트 기반의 라이브러리입니다. 이는 코드를 작은 조각, 즉 컴포넌트로 나누어 개발하게 함으로써 코드의 재사용성을 높이고, 유지 보수를 용이하게 합니다. 동일한 기능을 하는 컴포넌트를 재사용함으로써 개발 시간을 단축할 수 있습니다.&lt;/p&gt;&lt;h3&gt;2. Virtual Dom&lt;/h3&gt;&lt;p&gt;React는 실제 DOM(Document Object Model) 대신 가상의 DOM을 사용하여 성능을 향상시킵니다. 일반적인 상황에서는 변경 사항 발생 시 일반 DOM에 접근하여 전체 DOM을 변경합니다. 하지만 Virtual DOM을 사용하면 변경 사항을 먼저 가상의 DOM에 적용한 후, 최종적으로 변경된 부분만 실제 DOM에 반영함으로써 불필요한 렌더링을 줄입니다. 이를 통해 브라우저의 연산 과정을 최소화하고 사용자의 자원 사용을 줄일 수 있습니다. 이는 특히 동적인 웹 애플리케이션에서 중요한 성능 향상을 가져옵니다.&lt;/p&gt;&lt;h3&gt;3. JSX&lt;/h3&gt;&lt;p&gt;JSX는 HTML과 Javascript의 결합으로 확장된 문법입니다. ****이를 통해 렌더링 로직과 UI 로직이 연결되어, 각각의 로직이 분리된 파일에 존재하는 것이 아닌 하나의 컴포넌트 안에서 연결되어 각 로직을 수행합니다. 이는 더욱 직관적인 코드 작성이 가능하도록 합니다. JSX는 또한 렌더링 전 문자열로 변환하여 작성된 내용만 주입한다는 특징을 갖고 있습니다. 이를 통해 XSS(cross-site-scripting) 공격을 방지하는 데 도움이 됩니다.&lt;/p&gt;&lt;h3&gt;4. 강력한 생태계&lt;/h3&gt;&lt;p&gt;가장 인기 있는 Frontend framework인 React는 강력한 생태계를 가지고 있습니다. 또한, 큰 커뮤니티와 다양한 라이브러리들이 존재하여 개발자가 사용하고자 하는 것을 선택하여 적용할 수 있습니다. 대형 IT 기업인 Facebook에서 만든 React로 인해 전문가들의 충분한 지원을 받음으로써 개발자들은 다양한 도구와 자원을 활용할 수 있습니다.&lt;/p&gt;&lt;h3&gt;5. 단방향 데이터 흐름&lt;/h3&gt;&lt;p&gt;React는 부모 컴포넌트에서 자식 컴포넌트로만 데이터를 전달합니다. 이러한 단방향 데이터 흐름은 데이터의 변화를 예측 가능하게 하고, 디버깅에 용이하다는 장점을 가지고 있습니다. 또한, 애플리케이션 내에서 상태 변화의 추적이 편리하고 복잡한 데이터 관리 문제를 해결할 수 있습니다.&lt;/p&gt;&lt;h2&gt;결론&lt;/h2&gt;&lt;p&gt;이 글을 통해 React의 중요성과 그 이유를 알아보았습니다. React의 특징인 컴포넌트 기반 구조, Virtual DOM, JSX, 강력한 생태계, 단방향 데이터 흐름 등은 프론트엔드 개발에 있어 큰 이점을 제공합니다. 이러한 React의 특징을 활용한다면, 더 나은 개발 경험을 가질 수 있을 것입니다.&lt;/p&gt;</content:encoded><author>8410294@naver.com</author></item><item><title><![CDATA[소개글]]></title><description><![CDATA[👨‍💻 Frontend Engineer, Web Developer 😀  세상에 편리한 시스템 제공을 목표로 하는 개발자입니다! 😃 👦 Profile 👶  2000년 01월 04일 출생 🏫  전북제일고등학교 졸업 (2015.0…]]></description><link>https://lcy042000.github.io/introduce-post</link><guid isPermaLink="false">https://lcy042000.github.io/introduce-post</guid><category><![CDATA[introduce]]></category><category><![CDATA[aboutme]]></category><pubDate>Tue, 21 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;&lt;span role=&quot;img&quot; aria-label=&quot;man technologist&quot;&gt;👨‍💻&lt;/span&gt; Frontend Engineer, Web Developer&lt;/h2&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;grinning face&quot;&gt;😀&lt;/span&gt;  세상에 편리한 시스템 제공을 목표로 하는 개발자입니다! &lt;span role=&quot;img&quot; aria-label=&quot;grinning face with big eyes&quot;&gt;😃&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span role=&quot;img&quot; aria-label=&quot;boy&quot;&gt;👦&lt;/span&gt; Profile&lt;/h2&gt;&lt;hr/&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;baby&quot;&gt;👶&lt;/span&gt;  2000년 01월 04일 출생&lt;/p&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;school&quot;&gt;🏫&lt;/span&gt;  전북제일고등학교 졸업 (2015.03. ~ 2018.02.)&lt;/p&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;man student&quot;&gt;👨‍🎓&lt;/span&gt;  금오공과대학교 컴퓨터소프트웨어공학과 재학 중 (2018.03 ~ )&lt;/p&gt;&lt;h2&gt;&lt;span role=&quot;img&quot; aria-label=&quot;light bulb&quot;&gt;💡&lt;/span&gt; Contact&lt;/h2&gt;&lt;hr/&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;open mailbox with lowered flag&quot;&gt;📭&lt;/span&gt;  &lt;a href=&quot;mailto:8410294@naver.com&quot;&gt;8410294@naver.com&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;telephone receiver&quot;&gt;📞&lt;/span&gt;  010-6223-0295&lt;/p&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;blue book&quot;&gt;📘&lt;/span&gt;  &lt;a href=&quot;https://www.linkedin.com/in/%EC%B6%A9%EC%97%BD-%EC%9D%B4-28a154283/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Linkedin Link&lt;/a&gt; &lt;/p&gt;&lt;h2&gt;🎞 Career&lt;/h2&gt;&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;신호처리 및 지능형네트워크 연구실 소속 학부 연구생(2022.03 ~ )&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span role=&quot;img&quot; aria-label=&quot;magic wand&quot;&gt;🪄&lt;/span&gt;Intro.&lt;/h3&gt;&lt;hr/&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;light bulb&quot;&gt;💡&lt;/span&gt; 일을 시작하면 스스로 마무리하기 위해 노력합니다. 문제가 발생하더라도 끝까지 해결 방안을 찾기 위해 노력합니다.&lt;/p&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;question mark&quot;&gt;❓&lt;/span&gt; 부족한 부분을 채우기 위해 나에게 필요한 것이 무엇인지 매일 질문합니다.&lt;/p&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;keyboard&quot;&gt;⌨️&lt;/span&gt; 사용자가 편리한 시스템 개발을 위해 노력합니다.&lt;/p&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;motorway&quot;&gt;🛣️&lt;/span&gt; 읽기 쉽고 효율적인 코드가 좋은 코드라는 가치관 아래 프로그래밍을 수행합니다.&lt;/p&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;alarm clock&quot;&gt;⏰&lt;/span&gt; 매일 계획을 세워 지키려고 노력합니다. 매일 밤 내일 할 일을 정리하여 계획합니다.&lt;/p&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;man biking (skin tone 6)&quot;&gt;🚴🏿‍♂️&lt;/span&gt; 매일 두 시간 운동을 통해 자신을 관리합니다.&lt;/p&gt;&lt;h2&gt;🗃 Github&lt;/h2&gt;&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/lcy042000&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;lcy042000 - Overview&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;🪪Certificate&lt;/h2&gt;&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;OPIc&lt;/strong&gt; - IM1&lt;/li&gt;&lt;li&gt;&lt;strong&gt;정보처리기사&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span role=&quot;img&quot; aria-label=&quot;hammer and pick&quot;&gt;⚒️&lt;/span&gt; Skills&lt;/h2&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt; Language&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;JavaScript / TypeScript / Java&lt;/p&gt;&lt;p&gt;&lt;strong&gt; Framework &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;React.js&lt;/p&gt;&lt;p&gt;&lt;strong&gt; Library &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;React-Query / Recoil / Three,js / Nivo Chart / TailwondCSS / Chakra UI&lt;/p&gt;&lt;p&gt;&lt;strong&gt; Tool &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Git / Figma&lt;/p&gt;&lt;h2&gt;⚒ Personal &amp;amp; Team Project&lt;/h2&gt;&lt;hr/&gt;&lt;h3&gt;&lt;strong&gt;SE Board 리뉴얼&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;금오공과대학교 컴퓨터소프트웨어공학과 커뮤니티&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.seboard.site&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;↗SE Board(커뮤니티 링크)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;기간&lt;/strong&gt; 2023.01~&lt;/p&gt;&lt;p&gt;&lt;strong&gt;기술스택&lt;/strong&gt; &lt;a href=&quot;https://www.typescriptlang.org/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;TypeScript&lt;/a&gt;, &lt;a href=&quot;https://ko.legacy.reactjs.org/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;React.js,&lt;/a&gt; &lt;a href=&quot;https://chakra-ui.com/?ref=retool-blog&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Chakra UI,&lt;/a&gt; &lt;a href=&quot;https://tanstack.com/query/v3/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;React-Query,&lt;/a&gt; &lt;a href=&quot;https://ckeditor.com/ckeditor-5/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;CKEditor5,&lt;/a&gt; &lt;a href=&quot;https://recoiljs.org/ko/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Recoil,&lt;/a&gt; &lt;a href=&quot;https://www.figma.com/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Figma&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;GitHub&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kit-SE-Project/SE-FE&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://github.com/kit-SE-Project/SE-FE&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;참여 파트&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Frontend 개발&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;TypeScript를 사용한 구현으로 &lt;strong&gt;코드의 재사용성&lt;/strong&gt;과 &lt;strong&gt;효율성&lt;/strong&gt; 향상&lt;/li&gt;&lt;li&gt;React-Query의 캐싱을 활용한 &lt;strong&gt;데이터 관리&lt;/strong&gt; 및 &lt;strong&gt;성능&lt;/strong&gt; 향상&lt;/li&gt;&lt;li&gt;WYSIWYG 에디터인 CKEditor5 사용&lt;/li&gt;&lt;li&gt;스타일 기반 Chakra UI를 통한 유연성&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;개발 기능&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;UI 설계 및 디자인&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;커뮤니티 기능&lt;/p&gt;&lt;ul&gt;&lt;li&gt;사용자 권한별 게시글 조회&lt;/li&gt;&lt;li&gt;댓글 CRUD&lt;/li&gt;&lt;li&gt;게시글 작성 및 수정 기능&lt;/li&gt;&lt;li&gt;게시글 및 댓글 스크랩, 공유, 신고 기능&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;관리자 기능&lt;/p&gt;&lt;ul&gt;&lt;li&gt;커뮤니티 게시판(카테고리) 관리&lt;/li&gt;&lt;li&gt;관리자 메뉴 권한 설정 기능&lt;/li&gt;&lt;li&gt;회원 관리&lt;/li&gt;&lt;li&gt;댓글 관리&lt;/li&gt;&lt;li&gt;휴지통&lt;/li&gt;&lt;li&gt;일반 정책 관리&lt;/li&gt;&lt;li&gt;메인 페이지 관리(배너, 상단바 메뉴 설정)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;h3&gt;&lt;strong&gt;햄버거 가게 주문 및 배달 시스템&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;고급 웹 프로그래밍 교과목 프로젝트로 햄버거 가게의 주문 및 배달 시스템 개발&lt;/p&gt;&lt;p&gt;&lt;strong&gt;기간&lt;/strong&gt; 2023.05 ~ 2023.06&lt;/p&gt;&lt;p&gt;&lt;strong&gt;기술스택&lt;/strong&gt; &lt;a href=&quot;https://www.typescriptlang.org/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;TypeScript&lt;/a&gt;, &lt;a href=&quot;https://ko.legacy.reactjs.org/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;React.js,&lt;/a&gt; &lt;a href=&quot;https://chakra-ui.com/?ref=retool-blog&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Chakra UI,&lt;/a&gt; &lt;a href=&quot;https://tanstack.com/query/v3/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;React-Query,&lt;/a&gt; &lt;a href=&quot;https://nivo.rocks/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;nivo chart,&lt;/a&gt; &lt;a href=&quot;https://www.figma.com/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Figma&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;GitHub&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/WebProgramming-Project/Advanced_WP-FE&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://github.com/WebProgramming-Project/Advanced_WP-FE&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;참여 파트&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Frontend Engineer&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;WebRTC를 이용한 &lt;strong&gt;실시간 주문 현황 조회&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;OAuth를 통한 &lt;strong&gt;간편한 인증&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;개발 기능&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;UI 설계 및 디자인&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;시스템 UI 템플릿 구현&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;메뉴 상세 정보&lt;/p&gt;&lt;ul&gt;&lt;li&gt;햄버거 상세 정보 조회&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;장바구니&lt;/p&gt;&lt;ul&gt;&lt;li&gt;고객의 상품 장바구니 기능&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;OAuth 인증 시스템&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Google OAuth를 이용한 회원 가입 및 로그인 기능&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;주문 현황&lt;/p&gt;&lt;ul&gt;&lt;li&gt;고객 과거 주문 내역 조회&lt;/li&gt;&lt;li&gt;주문한 상품의 현재 상태를 WebRTC를 이용하여 주문 중/배달 중/배달 완료 조회 기능&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;h3&gt;&lt;strong&gt;미래금속 스마트 팩토리 시스템&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;산합협력 프로젝트인 지역 알루미늄 빌렛 생산 기업의 스마트 팩토리 시스템 구축 프로젝트에 학부 연구생으로 참여&lt;/p&gt;&lt;p&gt;&lt;strong&gt;기간&lt;/strong&gt; 2022.07 ~ 2022.12&lt;/p&gt;&lt;p&gt;&lt;strong&gt;기술스택&lt;/strong&gt; JavaScript, &lt;a href=&quot;https://ko.legacy.reactjs.org/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;React.js&lt;/a&gt;, &lt;a href=&quot;https://tailwindcss.com/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Tailwind CSS&lt;/a&gt;, &lt;a href=&quot;https://nivo.rocks/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;nivo chart&lt;/a&gt;, &lt;a href=&quot;https://threejs.org/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;three.js&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;참여 파트&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Frontend Engineer&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;3D 콘텐츠&lt;/strong&gt; 표현을 위한 Three.js 적용&lt;/li&gt;&lt;li&gt;nivo 라이브러리를 사용하여 &lt;strong&gt;데이터 차트 그래프&lt;/strong&gt; 구현&lt;/li&gt;&lt;li&gt;TailwindCSS를 통한 &lt;strong&gt;일관된 디자인&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;개발 기능&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;JWT 토큰을 이용한 로그인 &amp;amp; 로그아웃&lt;/li&gt;&lt;li&gt;통계&lt;ul&gt;&lt;li&gt;서버로부터 공정 과정에 발생한 데이터 조회 기능&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;3D 대시보드&lt;ul&gt;&lt;li&gt;WebGL을 이용하여 공장의 모형 3D 콘텐츠 구현&lt;/li&gt;&lt;li&gt;공정 과정 데이터와 날씨 데이터 상관 관계 전달 기능&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;관리자 기능&lt;ul&gt;&lt;li&gt;일지 작성 시 필요한 요소 관리&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;h1&gt;&lt;span role=&quot;img&quot; aria-label=&quot;grinning face with smiling eyes&quot;&gt;😄&lt;/span&gt; 감사합니다.&lt;/h1&gt;</content:encoded><author>8410294@naver.com</author></item></channel></rss>