<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[LEECY's Blog]]></title><description><![CDATA[This is LEECY's Blog]]></description><link>https://lcy042000.github.io</link><image><url>https://lcy042000.github.io/logos/leecy-logo-512W.png</url><title>LEECY&apos;s Blog</title><link>https://lcy042000.github.io</link></image><generator>GatsbyJS Advanced Starter</generator><lastBuildDate>Tue, 05 Dec 2023 12:37:31 GMT</lastBuildDate><atom:link href="https://lcy042000.github.io/rss.xml" rel="self" type="application/rss+xml"/><copyright><![CDATA[© Copyright 2021]]></copyright><item><title><![CDATA[[WHAT]var vs let vs const]]></title><description><![CDATA[var 키워드로 선언한 변수의 문제점 var 키워드는 ES5까지 변수를 선언할 수 있는 유일한 방법이었습니다. 하지만 이는 많은 문제점을 내포하고 있습니다. 변수 중복 선언 허용 var 키워드의 변수는 중복 선언이 가능합니다. var…]]></description><link>https://lcy042000.github.io/javascript-variable-keyword</link><guid isPermaLink="false">https://lcy042000.github.io/javascript-variable-keyword</guid><category><![CDATA[WHAT]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[VariableKeyword]]></category><category><![CDATA[let]]></category><category><![CDATA[var]]></category><category><![CDATA[const]]></category><pubDate>Tue, 05 Dec 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;var 키워드로 선언한 변수의 문제점&lt;/h2&gt;&lt;p&gt;var 키워드는 ES5까지 변수를 선언할 수 있는 유일한 방법이었습니다. 하지만 이는 많은 문제점을 내포하고 있습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;변수 중복 선언 허용&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;var 키워드의 변수는 중복 선언이 가능합니다. var 키워드로 선언한 변수를 중복 선언하면 초기화문 유무에 따라 다르게 동작합니다. 초기화문이 있는 변수 선언문은 자바스크립트 엔진에 의해 var 키워드기 없는 것처럼 동작하고 초기화문이 없는 변수 선언문은 무시됩니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;함수 레벨 스코프&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;var 키워드의 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정합니다. 따라서 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 됩니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;변수 호이스팅&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올라진 것처럼 동작합니다. 실제 변수를 선언하기 전이더라도 변수를 참조하면 undefined를 반환합니다. 이는 코드의 가독성을 저하시키고 오류를 발생할 여지를 남니다.&lt;/p&gt;&lt;h2&gt;let 키워드&lt;/h2&gt;&lt;p&gt;ES6에서 새롭게 도입된 변수 선언 키워드인 let에 대해 알아보도록 하겠습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;변수 중복 선언 금지&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;let 키워드의 경우 같은 이름의 변수를 중복 선언하면 문법 에러가 발생합니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;블록 레벨 스코프&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;모든 코드 블록(함수, if 문, for 문, while 문 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따릅니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;변수 호이스팅&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;let 키워드로 선언한 변수는 호이스팅이 발생하지 않는 것처럼 동작합니다. 변수 선언 이전에 변수를 참조할 경우 참조 에러를 발생시킵니다. let 키워드로 선언한 변수는 “선언 단계”와 “초기화 단계”가 분리되어 진행됩니다. 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 &lt;strong&gt;일시적 사각지대&lt;/strong&gt;라고 부릅니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;전역 객체와 let&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;var 키워드로 선언한 전역 변수와 전역 함수, 선언하지 않은 변수에 값을 할당한 암묵적 전역은 전역 객체 window의 프로퍼티가 됩니다. 하지만, let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아닙니다.&lt;/p&gt;&lt;h2&gt;const 키워드&lt;/h2&gt;&lt;p&gt;let 키워드와 대부분 같지만 차이점을 기반으로 알아보도록 하겠습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;선언과 초기화&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;const 키워드의 변수는 선언과 동시에 초기화해야 합니다. 그렇지 않은 경우, 문법 에러가 발생하게 됩니다. 또한 let 키워드와 마찬가지로 블록 레벨 스코프를 가지며 변수 호이스팅이 발생하지 않습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;재할당 금지 및 상수&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;const 키워드의 변수는 재할당이 불가합니다. 또한, const 변수는 상수로 값의 변경이 불가합니다. 한 번 초기화된 상수는 재할당이 금지됩니다. &lt;/p&gt;&lt;p&gt;&lt;strong&gt;const 키워드와 객체&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;const 키워드로 선언된 변수에 원시 값을 선언한 경우에는 값을 변경할 수 없지만 객체를 선언한 경우 값 변경이 가능합니다. const 키워드는 재할당을 금지하는 것이며 값이 변하는 ‘불변’을 의미하지 않기 때문에 객체의 프로퍼티 생성, 삭제, 변경은 가능합니다. 하지만, 변수에 할당된 참조 값의 변경은 불가합니다.&lt;/p&gt;&lt;h2&gt;var vs let vs const&lt;/h2&gt;&lt;p&gt;변수 선언 시에는 const를 우선적으로 사용하고, 값의 변경이 있을 수 있는 경우 let을 사용하는 것이 좋습니다. 변수의 스코프는 최대한 좁게 설정하고 var 키워드의 사용을 지양하는 것이 좋은 코딩 습관입니다.&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;참고&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;이웅모, ⌈모던 자바스크립트 - Deep Dive⌋, 2020, 15_let, const 키워드와 블록 레벨 스코프(p.208 - 218)&lt;/p&gt;</content:encoded><author>8410294@naver.com</author></item><item><title><![CDATA[[HOW]JavaScript의 객체 변경 방지 방법]]></title><description><![CDATA[…]]></description><link>https://lcy042000.github.io/prevent-object-changes</link><guid isPermaLink="false">https://lcy042000.github.io/prevent-object-changes</guid><category><![CDATA[HOW]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[Object]]></category><pubDate>Tue, 05 Dec 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;객체 변경 방지&lt;/h2&gt;&lt;p&gt;객체 변경 가능한 값으로 재할당 없이 프로퍼티의 생성, 변경, 삭제가 가능합니다. 자바스크립트는 객체의 변경을 방지하기 위해 다양한 기능을 제공합니다. 여러 객체 변경 방지 메서드들은 각각 객체의 변경 금지 정도가 다릅니다. 지금부터 각 메서드들에 대해 알아보도록 하겠습니다.&lt;/p&gt;&lt;h2&gt;객체 확장 금지&lt;/h2&gt;&lt;p&gt;객체의 확장을 금지하는 메서드는 Object.preventExtensions()입니다. 객체 확장 금지는 프로퍼티를 추가하는 것을 방지하는 것입니다. 객체의 프로퍼티는 동적 추가와 Object.defineProperty()로 가능하지만 확장이 금지된 경우에는 두 가지 방법 모두 불가능합니다. 객체의 확장 가능 여부는 Object.isExtensible()로 확인 가능합니다.&lt;/p&gt;&lt;h2&gt;객체 밀봉&lt;/h2&gt;&lt;p&gt;객체 밀봉이란 프로퍼티 추가 및 삭제, 프로퍼티 어트리뷰트 재정의 금지를 의미합니다. 밀봉된 객체는 읽기와 쓰기만 가능하며 Object.seal()로 객체를 밀봉할 수 있습니다. 객체가 밀봉됐는지 확인은 Object.isSealed()로 가능합니다.&lt;/p&gt;&lt;h2&gt;객체 동결&lt;/h2&gt;&lt;p&gt;객체 동결은 프로퍼티 추가, 삭제, 프로퍼티 어트리뷰트 재정의 금지, 프로퍼티 값 갱신 금지를 의미하며 동결된 객체는 읽기만 가능합니다. Object.freeze()를 통해 객체를 동결할 수 있습니다. Object.isFrozen()을 통해 객체 동결 여부를 확인할 수 있습니다.&lt;/p&gt;&lt;h2&gt;불변 객체&lt;/h2&gt;&lt;p&gt;객체 확장 금지, 객체 밀봉, 객체 동결은 얕은 변경 방지로 중첩된 객체는 영향을 끼칠 수 없습니다. 중첩된 객체까지 변경이 불가능한 객체를 만들기 위해서는 객체를 값으로 갖는 프로퍼티까지 재귀적으로 객체 변경 방지 메서드를 호출해야 합니다.&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;참고&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;이웅모, ⌈모던 자바스크립트 - Deep Dive⌋, 2020, 16_프로퍼티 어트리뷰트(p.229 - 233)&lt;/p&gt;</content:encoded><author>8410294@naver.com</author></item><item><title><![CDATA[[HOW]전역 변수의 사용을 억제하는 방법]]></title><description><![CDATA[…]]></description><link>https://lcy042000.github.io/not-global-variable-method</link><guid isPermaLink="false">https://lcy042000.github.io/not-global-variable-method</guid><category><![CDATA[HOW]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[Global variable]]></category><pubDate>Thu, 30 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;전역 변수의 무분별한 사용은 위험한 결과를 초래할 수 있습니다. 전역 변수를 반드시 사용해야 하는 경우가 아니라면 사용을 자제해야 하며, 지역 변수를 사용해야 합니다. 지금부터 전역 변수의 사용을 줄일 수 있는 방법에 대해 알아보겠습니다.&lt;/p&gt;&lt;h3&gt;즉시 실행 함수&lt;/h3&gt;&lt;p&gt;함수 정의와 동시에 호출되는 즉시 실행 함수는 단 한 번만 호출되며, 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 됩니다.&lt;/p&gt;&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; foo &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;네임스페이스 객체&lt;/h3&gt;&lt;p&gt;전역 코드에 네임스페이스 객체를 생성하고 전역 변수처럼 사용코자 하는 변수를 프로퍼티로 추가하는 방법입니다. 하지만, 식별자 충돌 방지 효과는 있으나 네임스페이스 객체 자체가 전역 변수에 해당되어 좋은 방법은 아닙니다.&lt;/p&gt;&lt;h3&gt;모듈 패턴&lt;/h3&gt;&lt;p&gt;관련 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만드는 방법입니다. 모듈 패턴은 클로저를 기반으로 동작하여 전역 변수 사용 억제뿐만 아니라 캡슐화까지 구현할 수 있습니다.&lt;/p&gt;&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; Counter &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; num &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;token function&quot;&gt;increase&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;num&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;

		&lt;span class=&quot;token function&quot;&gt;decrease&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;num&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;ES6 모듈&lt;/h3&gt;&lt;p&gt;ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공합니다. 따라서 모듈 내에서 선언된 변수는 전역 변수가 아닙니다. 모던 브라우저에서 모듈을 사용할 수 있습니다.&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;참고&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;이웅모, ⌈모던 자바스크립트 - Deep Dive⌋, 2020, 14_전역 변수의 문제점(p.204 - 207)&lt;/p&gt;</content:encoded><author>8410294@naver.com</author></item><item><title><![CDATA[[WHAT]전역 변수의 문제점]]></title><description><![CDATA[…]]></description><link>https://lcy042000.github.io/global-variable-problem</link><guid isPermaLink="false">https://lcy042000.github.io/global-variable-problem</guid><category><![CDATA[WHAT]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[Global variable Problem]]></category><pubDate>Thu, 30 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;변수의 생명 주기&lt;/h2&gt;&lt;p&gt;변수는 선언에 의해 생성되고 할당을 통해 값을 갖습니다. 변수는 자신이 선언된 위치에서 생성되고 소멸합니다. 지역 변수의 생명 주기는 함수의 생명 주기와 동일합니다. 함수가 호출된 직후 함수 몸체의 코드가 한 줄씩 순차적으로 실행되기 이전에 자바스크립트 엔진에 의해 먼저 실행됩니다. 전역 변수의 경우 함수와 달리 전역 코드는 명시적인 호출과 종료가 없기 때문에 전역 코드와 생명 주기가 동일합니다.&lt;/p&gt;&lt;h2&gt;전역 변수의 문제점&lt;/h2&gt;&lt;h3&gt;1. 암묵적 결합&lt;/h3&gt;&lt;p&gt;전역 변수를 선언한 이유는 코드의 어느 영역에서나 참조하고 할당할 수 있는 변수를 사용하겠다는 뜻입니다. 이는 모든 코드가 전역 변수를 참조하고 변경할 수 있는 &lt;strong&gt;암묵적 결합&lt;/strong&gt;을 허용하는 것입니다. 변수의 유효 범위가 넓어질수록 코드의 가독성을 저하시키고 의도치 않는 변경을 유발할 수 있습니다.&lt;/p&gt;&lt;h3&gt;2. 긴 생명 주기&lt;/h3&gt;&lt;p&gt;전역 변수는 생명 주기가 길기 때문에, 그만큼 메모리 리소스도 사용하게 됩니다. 또한, 전역 변수의 상태를 변경할 수 있는 시간이 길고 기회도 많게 됩니다. 반면에, 지역 변수는 전역 변수보다 생명 주기가 짧고 메모리 리소스 사용도 적기 때문에 오류 발생 확률이 적습니다.&lt;/p&gt;&lt;h3&gt;3. 스코프 체인 상에서 종점 존재&lt;/h3&gt;&lt;p&gt;변수 검색 시 전역 변수가 사장 마지막에 검색되는 스코프 체인 상의 종점에 존재합니다. 따라서, 전역 변수의 검색 속도가 가장 느리기 때문에 성능 저하가 발생할 수 있습니다.&lt;/p&gt;&lt;h3&gt;4. 네임스페이스 오염&lt;/h3&gt;&lt;p&gt;자바스크립트의 문제점 중 하나는 파일이 분리되어 있더라고 하나의 전역 스코프를 공유한다는 것입니다. 만약의 경우, 각각 다른 파일에 동일한 이름의 변수가 존재한다면 예상하지 못한 결과를 가져올 수 있습니다.&lt;/p&gt;&lt;h2&gt;전역 변수 사용 억제법&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://lcy042000.github.io/not-global-variable-method&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://lcy042000.github.io/not-global-variable-method&lt;/a&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;참고&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;이웅모, ⌈모던 자바스크립트 - Deep Dive⌋, 2020, 14_전역 변수의 문제점(p.204 - 207)&lt;/p&gt;</content:encoded><author>8410294@naver.com</author></item><item><title><![CDATA[[WHAT]자바스크립트의 스코프]]></title><description><![CDATA[…]]></description><link>https://lcy042000.github.io/java-script-scope</link><guid isPermaLink="false">https://lcy042000.github.io/java-script-scope</guid><category><![CDATA[WHAT]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[Scope]]></category><pubDate>Wed, 29 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;스코프란?&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;스코프&lt;/strong&gt;는 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)가 자신이 선언된 위치에 따라 다른 코드에서 참조할 수 있는 유효 범위를 의미합니다. 스코프는 식별자의 검색 규칙이며, 이를 통해 자바스크립트 엔진은 어떤 변수를 참조할지 결정합니다.&lt;/p&gt;&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&amp;#x27;global&amp;#x27;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&amp;#x27;local&amp;#x27;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// local&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// global&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위의 예제에서 함수 내부와 외부에서 &amp;#x27;x&amp;#x27;변수를 참조할 때, 자바스크립트 엔진은 어떤 변수를 참조할지 결정해야 합니다. 이러함 참조 결정을 &lt;strong&gt;식별자 결정&lt;/strong&gt;이라고 합니다. 자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조할지 결정하기 때문에 &lt;strong&gt;스코프를 식별자 검색 시 사용하는 규칙&lt;/strong&gt;이라고 할 수 있습니다. &lt;/p&gt;&lt;h2&gt;스코프의 종류&lt;/h2&gt;&lt;p&gt;자신이 선언된 위치에 의해 자신이 유효한 범위인 스코프가 결정됩니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;전역과 전역 스코프:&lt;/strong&gt; 전역이란 코드의 가장 바깥 영역을 말하며, 전역은 전역 스코프(global scope)를 만듭니다. 전역 스코프를 가진 식별자는 코드 어느 곳에서나 참조가 가능합니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;지역과 지역 스코프:&lt;/strong&gt; 지역은 함수 몸체 내부를 말합니다. 지역은 지역 스코프를 만들며, 지역 스코프를 가진 식별자는 자신이 선언된 지역과 하위 지역(중첩 함수)에서만 참조가 가능합니다.&lt;/p&gt;&lt;h2&gt;스코프 체인&lt;/h2&gt;&lt;p&gt;함수는 전역에서 정의될 수 있고, 함수 내부에서도 정의될 수 있습니다. 함수 몸체 내부에서 정의된 함수를 중첩 함수라고 하며, 중첩 함수를 포함하는 함수를 외부 함수라고 합니다.&lt;/p&gt;&lt;p&gt;함수가 중첩될 수 있으므로 함수의 지역 스코프도 중첩될 수 있습니다. 이 경우 스코프가 함수의 중첩에 의해 계층적 구조를 갖습니다. 모든 지역 스코프의 최상위 스코프는 전역 스코프이며 외부 함수의 지역 스코프, 내부 함수의 지역 스코프 순으로 계층이 존재합니다. 이를 &lt;strong&gt;스코프 체인&lt;/strong&gt;이라고 합니다. 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색합니다. 상위 스코프에서 유효한 변수는 하위 스코프에서 참조 가능하지만 하위 스코프의 변수는 상위 스코프에서 참조 불가능합니다.&lt;/p&gt;&lt;h2&gt;함수 레벨 스코프&lt;/h2&gt;&lt;p&gt;대부분의 프로그래밍 언어는 함수 몸체뿐만 아니라 코드 블록(if, for, while 등)도 지역 스코프를 만들지만, 자바스크립트는 함수만이 지역 스코프를 생성합니다. 코드 블록이 만드는 스코프는 &lt;strong&gt;블록 레벨 스코프&lt;/strong&gt;라 합니다. var 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정하며, 이러한 특성을 &lt;strong&gt;함수 레벨 스코프&lt;/strong&gt;라 합니다. 반면, ES6에서 도입된 let, const 키워드는 블록 레벨 스코프를 지원합니다.&lt;/p&gt;&lt;h2&gt;렉시컬 스코프&lt;/h2&gt;&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token function&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위의 코드는 bar 함수의 상위 스코프가 무엇인지에 따라 결정되며 두 가지 패턴을 예측할 수 있습니다.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정한다.&lt;/li&gt;&lt;li&gt;함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;첫 번째 방식은 &lt;strong&gt;동적 스코프&lt;/strong&gt;로 함수가 호출되는 시점에 따라 동적으로 상위 스코프가 결정됩니다. 두 번째 방식을 렉시컬 스코프 또는 정적 스코프라 하며 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정됩니다. 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 &lt;strong&gt;렉시컬 스코프&lt;/strong&gt;를 따릅니다.&lt;/p&gt;&lt;p&gt;따라서, 자바스크립트는 함수를 어디서 정의했는지에 따라 상위 스코프를 결정하며, 함수 호출 위치는 상위 스코프 결정에 영향을 주지 않습니다.&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;참고&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;이웅모, ⌈모던 자바스크립트 - Deep Dive⌋, 2020, 13_스코프(p.189 - 199)&lt;/p&gt;</content:encoded><author>8410294@naver.com</author></item><item><title><![CDATA[[WHAT]JavaScript란 무엇일까?]]></title><description><![CDATA[자바스크립트의 역사 199…]]></description><link>https://lcy042000.github.io/what-java-script</link><guid isPermaLink="false">https://lcy042000.github.io/what-java-script</guid><category><![CDATA[WHAT]]></category><category><![CDATA[JavaScript]]></category><pubDate>Tue, 28 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;aside&gt;💡 모든 브라우저의 표준 프로그래밍 언어이자 현재 웹 애플리케이션 개발에서 빠질 수 없는 존재인 JavaScript에 대해 알아봅시다!&lt;/aside&gt;&lt;img src=&quot;https://redmonk.com/rstephens/files/2023/05/redmonk-language-rankings-jan-2023.jpg&quot; alt=&quot;지난 10년간 프로그래밍 언어 순위&quot;/&gt;&lt;h2&gt;자바스크립트의 역사&lt;/h2&gt;&lt;p&gt;1995년, 웹 페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어 도입을 위해 자바스크립트가 개발되었습니다. 초기에는 각 브라우저 제조사에서 자체적으로 자바스크립트의 기능을 추가함으로써 브라우저에 따라 웹 페이지가 정상적으로 동작하지 않게 되는 &lt;strong&gt;크로스 브라우징 이슈&lt;/strong&gt;가 발생하게 됨을 뜻합니다.&lt;/p&gt;&lt;p&gt;따라서, 자바스크립트의 파편화를 방지하고 모든 브라우저에서 정상적으로 동작할 수 있는 표준화된 자바스크립트의 필요성이 대두되었습니다. 이를 위해, 비영리 표준화 기구인 ECMA 인터네셔널이 표준화를 요청하여 1997년 표준화된 자바스크립트 &lt;strong&gt;ECMAScript&lt;/strong&gt;가 발표되었습니다.&lt;/p&gt;&lt;h2&gt;자바스크립트의 성장&lt;/h2&gt;&lt;p&gt;초창기 자바스크립트는 웹 페이지의 보조적인 역할만을 수행하였습니다. 하지만 점차 기술들이 발전하며 자바스크립트의 활용은 늘어갔습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1. Ajax(Asynchronous JavaScript and XML)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Ajax는 서버와 브라우저가 &lt;strong&gt;비동기 방식&lt;/strong&gt;으로 데이터를 교환할 수 있는 통신 기능입니다. 이전에는 HTML 코드를 전달받아 렌더링하는 방식으로 동작했지만, 필요한 데이터만 전달받아 일부 부분만 렌더링하는 방식이 가능해졌습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2. jQuery&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;jQuery는 조작하기 어려웠던 DOM(Document Object Model)을 쉽게 다룰 수 있게 해주는 라이브러리입니다. 또한, 크로스 브라우징 이슈도 해결할 수 있었습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3. V8 자바스크립트 엔진&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;웹 프로그래밍 언어로서 가능성이 확인된 자바스크립트의 사용이 늘면서 더욱 발전된 자바스크립트 엔진이 요구되었습니다. 이로 인해, 2008년 구글은 V8 자바스크립트 엔진을 선보였고 이는 자바스크립트가 웹 애플리케이션 프로그래밍 언어로 정착하게 될 수 있는 계기가 되었습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4. Node.js&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Node.js는 구글 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경입니다. 브라우저의 자바스크립트 엔진에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서도 동작할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 실행 환경입니다. Node.js는 &lt;strong&gt;비동기 입출력&lt;/strong&gt;을 지원하며 &lt;strong&gt;단일 스레드 이벤트 루프 기반&lt;/strong&gt;으로 동작하여 요청 처리 성능이 우수합니다. Node.js로 인해 프론트엔드 개발에서만 사용하던 자바스크립트를 백엔드 개발에도 활용할 수 있게 되었습니다. 그 결과, 자바스크립트는 크로스 플랫폼을 위한 언어로 주목받게 되었습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;5. SPA 프레임워크&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;현재의 웹 시스템은 뛰어난 성능과 사용자 경험을 제공해야 하는 것이 필수가 되었고, 이는 개발 복잡도를 상승시켰습니다. 이전과 달리 복잡해진 개발 과정을 수행하기 위해 많은 프레임워크들이 등장했고, 그 중 &lt;strong&gt;CBD(Component based development)방법론&lt;/strong&gt;을 기반으로 하는 &lt;strong&gt;SPA(Single Page Application)&lt;/strong&gt;가 대중화되어 React, Vue, Angular 등이 많은 사랑을 받고 있습니다.&lt;/p&gt;&lt;h2&gt;자바스크립트와 ECMAScript&lt;/h2&gt;&lt;p&gt;ECMAScript는 자바스크립트의 표준 사양으로 핵심 문법을 규정합니다. 브라우저 제조사들은 이를 준수하여 브라우저에 내장되는 자바스크립트 엔진을 구현합니다. 기본 골조를 이루는 ECMAScript를 기반으로 브라우저 제조사들이 별도로 Web API를 지원합니다.&lt;/p&gt;&lt;h2&gt;자바스크립트의 특징&lt;/h2&gt;&lt;p&gt;자바스크립트는 웹 브라우저에서 동작하는 유일한 프로그래밍 언어입니다. 다른 언어들과 마찬가지로 기존의 프로그래밍 언어로부터 많은 영향을 받아 기본 문법은 C언어, 자바와 유사하고 Self에서는 프로토타입 기반 상속, Scheme에서는 일급 함수의 개념을 차용했습니다. 자바스크립트는 개발자가 별도 컴파일 작업을 하지 않는 &lt;strong&gt;인터프리터 언어&lt;/strong&gt;로 대부분의 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합하여 처리 속도가 느린 인터프리터의 단점을 해소했습니다. 또한, 자바스크립트는 &lt;strong&gt;명령형&lt;/strong&gt;, &lt;strong&gt;함수형&lt;/strong&gt;, &lt;strong&gt;프로토타입 기반 객체지향 프로그래밍&lt;/strong&gt;을 지원하는 &lt;strong&gt;멀티 패러다임 프로그래밍 언어&lt;/strong&gt;입니다.&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;참고&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;이웅모, ⌈모던 자바스크립트 - Deep Dive⌋, 2020, 02_자바스크립트란?&lt;/p&gt;&lt;p&gt;JS 이미지 / &lt;a href=&quot;https://github.com/voodootikigod/logo.js&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://github.com/voodootikigod/logo.js&lt;/a&gt;&lt;/p&gt;&lt;p&gt;프로그래밍 언어 순위 이미지 / &lt;a href=&quot;https://redmonk.com/rstephens/2023/05/16/top20-jan2023/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://redmonk.com/rstephens/2023/05/16/top20-jan2023/&lt;/a&gt;&lt;/p&gt;</content:encoded><author>8410294@naver.com</author></item><item><title><![CDATA[[WHAT]React란 무엇일까?]]></title><description><![CDATA[들어가기에 앞서… 웹 개발에 관심이 있다면, 'React'라는 단어를 한 번쯤 들어봤을 것입니다. 이 자바스크립트 라이브러리는 웹 개발의 세계에서 큰 중요성을 차지하고 있습니다. 그렇다면 이 React…]]></description><link>https://lcy042000.github.io/what-react</link><guid isPermaLink="false">https://lcy042000.github.io/what-react</guid><category><![CDATA[WHAT]]></category><category><![CDATA[React]]></category><pubDate>Sun, 26 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;들어가기에 앞서…&lt;/h2&gt;&lt;p&gt;웹 개발에 관심이 있다면, &amp;#x27;React&amp;#x27;라는 단어를 한 번쯤 들어봤을 것입니다. 이 자바스크립트 라이브러리는 웹 개발의 세계에서 큰 중요성을 차지하고 있습니다. 그렇다면 이 React는 왜 만들어졌고 어떤 역할을 하는지 알아보도록 하겠습니다.&lt;/p&gt;&lt;h2&gt;React의 탄생 배경&lt;/h2&gt;&lt;p&gt;과거 웹 서비스는 주로 서버에서 HTML을 생성하여 클라이언트에게 제공하는 방식을 사용했습니다. 이는 서비스 제공자가 텍스트 기반의 콘텐츠만 제공하는 단방향 소통 방식이었습니다.&lt;/p&gt;&lt;p&gt;하지만, 디지털 플랫폼의 발전과 함께 사용자의 인터랙션에 따른 동적인 업데이트가 필요해졌고, 이를 위해 AJAX와 같은 기술이 등장하였습니다. 이를 기반으로 한 라이브러리인 jQuery 등이 널리 사용되었습니다.&lt;/p&gt;&lt;p&gt;그러나 사용량의 증가와 이로 인한 데이터의 증가로 웹 애플리케이션의 복잡성이 증가하면서 상태 관리가 점점 어려워졌습니다. 방대한 크기의 서비스를 제공하던 페이스북은 시스템을 유지 보수하기 위해 기존과 다른 방법이 필요했습니다. 이를 해결하기 위해 페이스북의 개발팀은 컴포넌트 기반의 개발 방식을 도입하였고, 이로써 React가 탄생하게 되었습니다.&lt;/p&gt;&lt;h2&gt;React란?&lt;/h2&gt;&lt;p&gt;React는 사용자 인터페이스를 구축하기 위한 JavaScript 라이브러리입니다. React는 싱글 페이지 애플리케이션(SPA)를 구현하며, 서버로부터 하나의 페이지만 받아오지만 라우팅을 통해 여러 화면을 제공합니다. 이는 규모가 큰 시스템에서 데이터 전송 과부화와 같은 성능 문제를 해결 가능하다는 이점을 갖고 있습니다.&lt;/p&gt;&lt;p&gt;React는 웹 페이지의 각 요소를 독립적인 컴포넌트로 취급하여, 이 컴포넌트들을 조합해 전체 애플리케이션을 구성합니다. 이는 각 컴포넌트가 자신의 상태를 관리하고, 다른 컴포넌트와 독립적으로 렌더링될 수 있게 함으로써, 코드의 재사용성을 높이고, 유지보수를 용이하게 합니다.&lt;/p&gt;&lt;p&gt;React의 또 다른 핵심 특징은 Virtual DOM입니다. React는 실제 DOM 대신 Virtual DOM을 사용하여, 변경 사항을 먼저 가상의 DOM에 적용한 후, 실제 DOM에 최소한의 변화만을 반영합니다. 이로 인해 React는 빠른 렌더링 성능을 보장합니다.&lt;/p&gt;&lt;h2&gt;마치며…&lt;/h2&gt;&lt;p&gt;React는 현재 웹 개발에서 주요한 도구로 사용되며, 다양한 기술과 결합하여 다양한 모습을 보여주고 있습니다. 지금까지 Front-end 개발에서 많은 사랑을 받고 있는 React가 어떻게 탄생하였고 무엇인지에 대해 알아보았습니다.&lt;/p&gt;</content:encoded><author>8410294@naver.com</author></item><item><title><![CDATA[[WHY]React를 왜 써야할까?]]></title><description><![CDATA[들어가기에 앞서… React는 프론트엔드 프레임워크에서 가장 인기 있는 프레임워크입니다. HTML, CSS, JS 등 기본적인 웹 기술을 익힌 후, 많은 프론트엔드 개발자들이 React…]]></description><link>https://lcy042000.github.io/why-react</link><guid isPermaLink="false">https://lcy042000.github.io/why-react</guid><category><![CDATA[WHY]]></category><category><![CDATA[React]]></category><pubDate>Fri, 24 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;들어가기에 앞서…&lt;/h2&gt;&lt;p&gt;React는 프론트엔드 프레임워크에서 가장 인기 있는 프레임워크입니다. HTML, CSS, JS 등 기본적인 웹 기술을 익힌 후, 많은 프론트엔드 개발자들이 React를 학습합니다.&lt;/p&gt;&lt;p&gt;저 역시 웹 프론트엔드 개발을 위한 학습 경로로 이러한 순서를 따랐습니다. 그러나 React를 배우기 시작하면서, 왜 이런 프레임워크가 필요한지, 그리고 React의 특별함이 무엇인지에 대한 궁금증이 생겼습니다. 이 글을 통해 그러한 의문을 해결하고, React의 중요성을 이해하는 데 도움이 되고자 합니다.&lt;/p&gt;&lt;h2&gt;React란?&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://lcy042000.github.io/what-react&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://lcy042000.github.io/what-react&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Front-end Framework는 왜 쓰는 걸까?&lt;/h2&gt;&lt;p&gt;프로그래밍에서 프레임워크는 복잡한 문제를 해결하거나 서술하는 데 사용되는 뼈대나 체계를 말합니다. 프레임워크는 개발자가 반복적인 기본 작업을 수행하는 데 들이는 시간을 줄여주며, 안정성이 검증된 코드를 제공하여 개발 과정을 단순화합니다.&lt;/p&gt;&lt;p&gt;프론트엔드 개발에서도 이러한 프레임워크의 필요성은 큽니다. 프론트엔드 프레임워크를 사용하면, UI 구성, 상태 관리, 라우팅 등의 복잡한 문제를 해결하는 데 도움이 됩니다. 또한, 보안에 관련된 복잡한 이슈를 프레임워크가 대신 처리해 주므로, 개발자는 기능 개발에 집중할 수 있습니다.&lt;/p&gt;&lt;h2&gt;React 사용의 이점&lt;/h2&gt;&lt;h3&gt;1. 컴포넌트 기반 구조&lt;/h3&gt;&lt;p&gt;React는 컴포넌트 기반의 라이브러리입니다. 이는 코드를 작은 조각, 즉 컴포넌트로 나누어 개발하게 함으로써 코드의 재사용성을 높이고, 유지 보수를 용이하게 합니다. 동일한 기능을 하는 컴포넌트를 재사용함으로써 개발 시간을 단축할 수 있습니다.&lt;/p&gt;&lt;h3&gt;2. Virtual Dom&lt;/h3&gt;&lt;p&gt;React는 실제 DOM(Document Object Model) 대신 가상의 DOM을 사용하여 성능을 향상시킵니다. 일반적인 상황에서는 변경 사항 발생 시 일반 DOM에 접근하여 전체 DOM을 변경합니다. 하지만 Virtual DOM을 사용하면 변경 사항을 먼저 가상의 DOM에 적용한 후, 최종적으로 변경된 부분만 실제 DOM에 반영함으로써 불필요한 렌더링을 줄입니다. 이를 통해 브라우저의 연산 과정을 최소화하고 사용자의 자원 사용을 줄일 수 있습니다. 이는 특히 동적인 웹 애플리케이션에서 중요한 성능 향상을 가져옵니다.&lt;/p&gt;&lt;h3&gt;3. JSX&lt;/h3&gt;&lt;p&gt;JSX는 HTML과 Javascript의 결합으로 확장된 문법입니다. ****이를 통해 렌더링 로직과 UI 로직이 연결되어, 각각의 로직이 분리된 파일에 존재하는 것이 아닌 하나의 컴포넌트 안에서 연결되어 각 로직을 수행합니다. 이는 더욱 직관적인 코드 작성이 가능하도록 합니다. JSX는 또한 렌더링 전 문자열로 변환하여 작성된 내용만 주입한다는 특징을 갖고 있습니다. 이를 통해 XSS(cross-site-scripting) 공격을 방지하는 데 도움이 됩니다.&lt;/p&gt;&lt;h3&gt;4. 강력한 생태계&lt;/h3&gt;&lt;p&gt;가장 인기 있는 Frontend framework인 React는 강력한 생태계를 가지고 있습니다. 또한, 큰 커뮤니티와 다양한 라이브러리들이 존재하여 개발자가 사용하고자 하는 것을 선택하여 적용할 수 있습니다. 대형 IT 기업인 Facebook에서 만든 React로 인해 전문가들의 충분한 지원을 받음으로써 개발자들은 다양한 도구와 자원을 활용할 수 있습니다.&lt;/p&gt;&lt;h3&gt;5. 단방향 데이터 흐름&lt;/h3&gt;&lt;p&gt;React는 부모 컴포넌트에서 자식 컴포넌트로만 데이터를 전달합니다. 이러한 단방향 데이터 흐름은 데이터의 변화를 예측 가능하게 하고, 디버깅에 용이하다는 장점을 가지고 있습니다. 또한, 애플리케이션 내에서 상태 변화의 추적이 편리하고 복잡한 데이터 관리 문제를 해결할 수 있습니다.&lt;/p&gt;&lt;h2&gt;결론&lt;/h2&gt;&lt;p&gt;이 글을 통해 React의 중요성과 그 이유를 알아보았습니다. React의 특징인 컴포넌트 기반 구조, Virtual DOM, JSX, 강력한 생태계, 단방향 데이터 흐름 등은 프론트엔드 개발에 있어 큰 이점을 제공합니다. 이러한 React의 특징을 활용한다면, 더 나은 개발 경험을 가질 수 있을 것입니다.&lt;/p&gt;</content:encoded><author>8410294@naver.com</author></item><item><title><![CDATA[소개글]]></title><description><![CDATA[👨‍💻 Frontend Engineer, Web Developer 😀  세상에 편리한 시스템 제공을 목표로 하는 개발자입니다! 😃 👦 Profile 👶  2000년 01월 04일 출생 🏫  전북제일고등학교 졸업 (2015.0…]]></description><link>https://lcy042000.github.io/introduce-post</link><guid isPermaLink="false">https://lcy042000.github.io/introduce-post</guid><category><![CDATA[introduce]]></category><category><![CDATA[aboutme]]></category><pubDate>Tue, 21 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;&lt;span role=&quot;img&quot; aria-label=&quot;man technologist&quot;&gt;👨‍💻&lt;/span&gt; Frontend Engineer, Web Developer&lt;/h2&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;grinning face&quot;&gt;😀&lt;/span&gt;  세상에 편리한 시스템 제공을 목표로 하는 개발자입니다! &lt;span role=&quot;img&quot; aria-label=&quot;grinning face with big eyes&quot;&gt;😃&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span role=&quot;img&quot; aria-label=&quot;boy&quot;&gt;👦&lt;/span&gt; Profile&lt;/h2&gt;&lt;hr/&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;baby&quot;&gt;👶&lt;/span&gt;  2000년 01월 04일 출생&lt;/p&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;school&quot;&gt;🏫&lt;/span&gt;  전북제일고등학교 졸업 (2015.03. ~ 2018.02.)&lt;/p&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;man student&quot;&gt;👨‍🎓&lt;/span&gt;  금오공과대학교 컴퓨터소프트웨어공학과 재학 중 (2018.03 ~ )&lt;/p&gt;&lt;h2&gt;&lt;span role=&quot;img&quot; aria-label=&quot;light bulb&quot;&gt;💡&lt;/span&gt; Contact&lt;/h2&gt;&lt;hr/&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;open mailbox with lowered flag&quot;&gt;📭&lt;/span&gt;  &lt;a href=&quot;mailto:8410294@naver.com&quot;&gt;8410294@naver.com&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;telephone receiver&quot;&gt;📞&lt;/span&gt;  010-6223-0295&lt;/p&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;blue book&quot;&gt;📘&lt;/span&gt;  &lt;a href=&quot;https://www.linkedin.com/in/%EC%B6%A9%EC%97%BD-%EC%9D%B4-28a154283/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Linkedin Link&lt;/a&gt; &lt;/p&gt;&lt;h2&gt;🎞 Career&lt;/h2&gt;&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;신호처리 및 지능형네트워크 연구실 소속 학부 연구생(2022.03 ~ )&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span role=&quot;img&quot; aria-label=&quot;magic wand&quot;&gt;🪄&lt;/span&gt;Intro.&lt;/h3&gt;&lt;hr/&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;light bulb&quot;&gt;💡&lt;/span&gt; 일을 시작하면 스스로 마무리하기 위해 노력합니다. 문제가 발생하더라도 끝까지 해결 방안을 찾기 위해 노력합니다.&lt;/p&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;question mark&quot;&gt;❓&lt;/span&gt; 부족한 부분을 채우기 위해 나에게 필요한 것이 무엇인지 매일 질문합니다.&lt;/p&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;keyboard&quot;&gt;⌨️&lt;/span&gt; 사용자가 편리한 시스템 개발을 위해 노력합니다.&lt;/p&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;motorway&quot;&gt;🛣️&lt;/span&gt; 읽기 쉽고 효율적인 코드가 좋은 코드라는 가치관 아래 프로그래밍을 수행합니다.&lt;/p&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;alarm clock&quot;&gt;⏰&lt;/span&gt; 매일 계획을 세워 지키려고 노력합니다. 매일 밤 내일 할 일을 정리하여 계획합니다.&lt;/p&gt;&lt;p&gt;&lt;span role=&quot;img&quot; aria-label=&quot;man biking (skin tone 6)&quot;&gt;🚴🏿‍♂️&lt;/span&gt; 매일 두 시간 운동을 통해 자신을 관리합니다.&lt;/p&gt;&lt;h2&gt;🗃 Github&lt;/h2&gt;&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/lcy042000&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;lcy042000 - Overview&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;🪪Certificate&lt;/h2&gt;&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;OPIc&lt;/strong&gt; - IM1&lt;/li&gt;&lt;li&gt;&lt;strong&gt;정보처리기사&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span role=&quot;img&quot; aria-label=&quot;hammer and pick&quot;&gt;⚒️&lt;/span&gt; Skills&lt;/h2&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt; Language&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;JavaScript / TypeScript / Java&lt;/p&gt;&lt;p&gt;&lt;strong&gt; Framework &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;React.js&lt;/p&gt;&lt;p&gt;&lt;strong&gt; Library &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;React-Query / Recoil / Three,js / Nivo Chart / TailwondCSS / Chakra UI&lt;/p&gt;&lt;p&gt;&lt;strong&gt; Tool &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Git / Figma&lt;/p&gt;&lt;h2&gt;⚒ Personal &amp;amp; Team Project&lt;/h2&gt;&lt;hr/&gt;&lt;h3&gt;&lt;strong&gt;SE Board 리뉴얼&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;금오공과대학교 컴퓨터소프트웨어공학과 커뮤니티&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.seboard.site&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;↗SE Board(커뮤니티 링크)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;기간&lt;/strong&gt; 2023.01~&lt;/p&gt;&lt;p&gt;&lt;strong&gt;기술스택&lt;/strong&gt; &lt;a href=&quot;https://www.typescriptlang.org/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;TypeScript&lt;/a&gt;, &lt;a href=&quot;https://ko.legacy.reactjs.org/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;React.js,&lt;/a&gt; &lt;a href=&quot;https://chakra-ui.com/?ref=retool-blog&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Chakra UI,&lt;/a&gt; &lt;a href=&quot;https://tanstack.com/query/v3/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;React-Query,&lt;/a&gt; &lt;a href=&quot;https://ckeditor.com/ckeditor-5/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;CKEditor5,&lt;/a&gt; &lt;a href=&quot;https://recoiljs.org/ko/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Recoil,&lt;/a&gt; &lt;a href=&quot;https://www.figma.com/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Figma&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;GitHub&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kit-SE-Project/SE-FE&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://github.com/kit-SE-Project/SE-FE&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;참여 파트&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Frontend 개발&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;TypeScript를 사용한 구현으로 &lt;strong&gt;코드의 재사용성&lt;/strong&gt;과 &lt;strong&gt;효율성&lt;/strong&gt; 향상&lt;/li&gt;&lt;li&gt;React-Query의 캐싱을 활용한 &lt;strong&gt;데이터 관리&lt;/strong&gt; 및 &lt;strong&gt;성능&lt;/strong&gt; 향상&lt;/li&gt;&lt;li&gt;WYSIWYG 에디터인 CKEditor5 사용&lt;/li&gt;&lt;li&gt;스타일 기반 Chakra UI를 통한 유연성&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;개발 기능&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;UI 설계 및 디자인&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;커뮤니티 기능&lt;/p&gt;&lt;ul&gt;&lt;li&gt;사용자 권한별 게시글 조회&lt;/li&gt;&lt;li&gt;댓글 CRUD&lt;/li&gt;&lt;li&gt;게시글 작성 및 수정 기능&lt;/li&gt;&lt;li&gt;게시글 및 댓글 스크랩, 공유, 신고 기능&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;관리자 기능&lt;/p&gt;&lt;ul&gt;&lt;li&gt;커뮤니티 게시판(카테고리) 관리&lt;/li&gt;&lt;li&gt;관리자 메뉴 권한 설정 기능&lt;/li&gt;&lt;li&gt;회원 관리&lt;/li&gt;&lt;li&gt;댓글 관리&lt;/li&gt;&lt;li&gt;휴지통&lt;/li&gt;&lt;li&gt;일반 정책 관리&lt;/li&gt;&lt;li&gt;메인 페이지 관리(배너, 상단바 메뉴 설정)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;h3&gt;&lt;strong&gt;햄버거 가게 주문 및 배달 시스템&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;고급 웹 프로그래밍 교과목 프로젝트로 햄버거 가게의 주문 및 배달 시스템 개발&lt;/p&gt;&lt;p&gt;&lt;strong&gt;기간&lt;/strong&gt; 2023.05 ~ 2023.06&lt;/p&gt;&lt;p&gt;&lt;strong&gt;기술스택&lt;/strong&gt; &lt;a href=&quot;https://www.typescriptlang.org/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;TypeScript&lt;/a&gt;, &lt;a href=&quot;https://ko.legacy.reactjs.org/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;React.js,&lt;/a&gt; &lt;a href=&quot;https://chakra-ui.com/?ref=retool-blog&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Chakra UI,&lt;/a&gt; &lt;a href=&quot;https://tanstack.com/query/v3/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;React-Query,&lt;/a&gt; &lt;a href=&quot;https://nivo.rocks/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;nivo chart,&lt;/a&gt; &lt;a href=&quot;https://www.figma.com/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Figma&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;GitHub&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/WebProgramming-Project/Advanced_WP-FE&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://github.com/WebProgramming-Project/Advanced_WP-FE&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;참여 파트&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Frontend Engineer&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;WebRTC를 이용한 &lt;strong&gt;실시간 주문 현황 조회&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;OAuth를 통한 &lt;strong&gt;간편한 인증&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;개발 기능&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;UI 설계 및 디자인&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;시스템 UI 템플릿 구현&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;메뉴 상세 정보&lt;/p&gt;&lt;ul&gt;&lt;li&gt;햄버거 상세 정보 조회&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;장바구니&lt;/p&gt;&lt;ul&gt;&lt;li&gt;고객의 상품 장바구니 기능&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;OAuth 인증 시스템&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Google OAuth를 이용한 회원 가입 및 로그인 기능&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;주문 현황&lt;/p&gt;&lt;ul&gt;&lt;li&gt;고객 과거 주문 내역 조회&lt;/li&gt;&lt;li&gt;주문한 상품의 현재 상태를 WebRTC를 이용하여 주문 중/배달 중/배달 완료 조회 기능&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;h3&gt;&lt;strong&gt;미래금속 스마트 팩토리 시스템&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;산합협력 프로젝트인 지역 알루미늄 빌렛 생산 기업의 스마트 팩토리 시스템 구축 프로젝트에 학부 연구생으로 참여&lt;/p&gt;&lt;p&gt;&lt;strong&gt;기간&lt;/strong&gt; 2022.07 ~ 2022.12&lt;/p&gt;&lt;p&gt;&lt;strong&gt;기술스택&lt;/strong&gt; JavaScript, &lt;a href=&quot;https://ko.legacy.reactjs.org/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;React.js&lt;/a&gt;, &lt;a href=&quot;https://tailwindcss.com/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Tailwind CSS&lt;/a&gt;, &lt;a href=&quot;https://nivo.rocks/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;nivo chart&lt;/a&gt;, &lt;a href=&quot;https://threejs.org/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;three.js&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;참여 파트&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Frontend Engineer&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;3D 콘텐츠&lt;/strong&gt; 표현을 위한 Three.js 적용&lt;/li&gt;&lt;li&gt;nivo 라이브러리를 사용하여 &lt;strong&gt;데이터 차트 그래프&lt;/strong&gt; 구현&lt;/li&gt;&lt;li&gt;TailwindCSS를 통한 &lt;strong&gt;일관된 디자인&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;개발 기능&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;JWT 토큰을 이용한 로그인 &amp;amp; 로그아웃&lt;/li&gt;&lt;li&gt;통계&lt;ul&gt;&lt;li&gt;서버로부터 공정 과정에 발생한 데이터 조회 기능&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;3D 대시보드&lt;ul&gt;&lt;li&gt;WebGL을 이용하여 공장의 모형 3D 콘텐츠 구현&lt;/li&gt;&lt;li&gt;공정 과정 데이터와 날씨 데이터 상관 관계 전달 기능&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;관리자 기능&lt;ul&gt;&lt;li&gt;일지 작성 시 필요한 요소 관리&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;h1&gt;&lt;span role=&quot;img&quot; aria-label=&quot;grinning face with smiling eyes&quot;&gt;😄&lt;/span&gt; 감사합니다.&lt;/h1&gt;</content:encoded><author>8410294@naver.com</author></item></channel></rss>